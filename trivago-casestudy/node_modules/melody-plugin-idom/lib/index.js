'use strict';

var t = require('babel-types');
var melodyTypes = require('melody-types');

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parentIsForStatement(path) {
    var parentPath = path.parentPath;


    if (!parentPath) {
        return false;
    }

    if (parentPath.is('ForStatement')) {
        return true;
    }

    if (parentPath.is('Element')) {
        return false;
    }

    return parentIsForStatement(parentPath);
}

var mountVisitor = {
    convert: {
        MountStatement: {
            exit: function exit(path) {
                var args = [];
                if (path.node.source) {
                    var source = path.node.source.value;
                    var localName = void 0;
                    if (path.node.name) {
                        localName = this.addImportFrom(source, path.node.name.name);
                    } else {
                        localName = this.addDefaultImportFrom(source, this.generateComponentUid(source));
                    }
                    path.scope.registerBinding(localName, path, 'var');
                    this.markIdentifier(localName);
                    args.push(t.identifier(localName));
                } else {
                    args.push(path.node.name);
                }
                if (path.node.key) {
                    if (path.get('key').is('StringLiteral')) {
                        args.push(path.node.key);
                    } else {
                        args.push(t.binaryExpression('+', t.stringLiteral(''), path.node.key));
                    }
                } else if (!parentIsForStatement(path) && this.options.generateKey) {
                    args.push(t.stringLiteral(this.generateKey()));
                } else {
                    args.push(t.nullLiteral());
                }
                if (path.node.argument) {
                    args.push(path.node.argument);
                }

                path.replaceWithJS(t.expressionStatement(t.callExpression(t.identifier(path.state.addImportFrom('melody-idom', 'component')), args)));
            }
        }
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var idomVisitor = {
    convert: {
        PrintStatement: {
            exit: function exit(path) {
                var value = path.get('value');
                path.replaceWithJS(value.is('ExpressionStatement') ? value.node : callIdomFunction(this, 'text', [value.node]));
            }
        },
        Element: {
            exit: function exit(path) {
                var el = path.node,
                    isSelfClosing = el.selfClosing || !el.children.length;

                if (isSelfClosing && !el.attributes.length) {
                    // empty element
                    path.replaceWithJS(openElementWithoutAttributes(this, 'elementVoid', el.name));
                } else {
                    var replacements = [];
                    var ref = void 0;
                    // has no attributes but has children
                    if (!el.attributes.length) {
                        replacements.push(openElementWithoutAttributes(this, 'elementOpen', el.name));
                    } else {
                        // has attributes
                        ref = openElementWithAttributes(this, path, el, replacements);
                    }

                    if (!isSelfClosing) {
                        closeElement(this, ref, replacements, el);
                    }
                    path.replaceWithMultipleJS.apply(path, replacements);
                }
            }
        },
        Fragment: {
            exit: function exit(path) {
                path.replaceWithJS(t.expressionStatement(path.node.value));
            }
        }
    }
};

function openElementWithAttributes(state, path, el, replacements) {
    var staticAttributes = [],
        attributes = [],
        dynamicAttributeExpressions = [];
    var ref = void 0;
    var key = void 0;
    var i = 0;
    for (var attrs = el.attributes, len = attrs.length; i < len; i++) {
        var attr = attrs[i];
        if (!melodyTypes.Node.isAttribute(attr)) {
            dynamicAttributeExpressions.push(attr);
        } else if (melodyTypes.Node.isIdentifier(attr.name) && attr.name.name === 'key') {
            key = attr.value;
        } else if (melodyTypes.Node.isIdentifier(attr.name) && attr.name.name === 'ref' && attr.isImmutable()) {
            staticAttributes.push(t.stringLiteral('ref'), t.callExpression(t.identifier(state.addImportFrom('melody-idom', 'ref')), [attr.value]));
        } else if (attr.isImmutable()) {
            staticAttributes.push(t.stringLiteral(attr.name.name), attr.value);
        } else {
            addStaticAttribute(attributes, attr);
        }
    }

    key = ensureKeyIsValid(state, key, staticAttributes.length);

    var staticId = getStaticId(state, path, staticAttributes);
    var openElement = dynamicAttributeExpressions.length ? openDynamicAttributesElement : openSimpleElement;

    openElement(state, path, ref, key, staticId, attributes, dynamicAttributeExpressions, replacements);
    return ref;
}

function ensureKeyIsValid(state, maybeKey, hasStaticAttributes) {
    if (maybeKey) {
        return melodyTypes.Node.isStringLiteral(maybeKey) ? maybeKey : t.binaryExpression('+', t.stringLiteral(''), maybeKey);
    }

    if (hasStaticAttributes && state.options.generateKey) {
        return t.stringLiteral(state.generateKey());
    }

    return t.nullLiteral();
}

function getStaticId(state, path, staticAttributes) {
    var staticId = void 0;
    if (staticAttributes.length) {
        var staticIdName = path.scope.generateUid('statics');
        staticId = t.identifier(staticIdName);

        path.scope.registerBinding(staticIdName, null, 'global');
        state.insertGlobalVariableDeclaration('const', staticId, t.arrayExpression(staticAttributes));
    } else {
        staticId = t.nullLiteral();
    }
    return staticId;
}

function openSimpleElement(state, path, ref, key, staticId, attributes, dynamicAttributeExpressions, replacements) {
    var el = path.node;
    var isSelfClosing = el.selfClosing || !el.children.length;
    var openElementCall = elementOpen(state, isSelfClosing ? 'elementVoid' : 'elementOpen', el.name, key, staticId, attributes);
    if (isSelfClosing && ref) {
        openElementCall = t.callExpression(t.identifier(state.addImportFrom('melody-idom', 'ref')), [ref, openElementCall]);
    }
    replacements.push(t.expressionStatement(openElementCall));
}

function addStaticAttribute(attributes, attr) {
    if (melodyTypes.Node.isIdentifier(attr.name)) {
        attributes.push(t.stringLiteral(attr.name.name), attr.value || t.booleanLiteral(true));
    } else {
        attributes.push(attr.name, attr.value || t.nullLiteral());
    }
}

function openDynamicAttributesElement(state, path, ref, key, staticId, attributes, dynamicAttributeExpressions, replacements) {
    var el = path.node;
    var isSelfClosing = el.selfClosing || !el.children.length;

    // there are dynamic attribute expressions
    replacements.push(t.expressionStatement(elementOpen(state, 'elementOpenStart', el.name, key, staticId, attributes)));
    // todo adjust unit tests to remove this line
    state.addImportFrom('melody-idom', 'elementOpenEnd');

    addDynamicAttributeCalls(state, path, dynamicAttributeExpressions, replacements);

    // close the opening tag
    replacements.push(callIdomFunction(state, 'elementOpenEnd', []));

    if (isSelfClosing) {
        if (ref) {
            replacements.push(callIdomFunction(state, 'ref', [ref]));
        }
        // insert skip to jump over any children
        replacements.push(callIdomFunction(state, 'skip', []));
        // we handle closing the tag here since there is
        // no equivalent of 'elementVoid' when using dynamic attributes
        replacements.push(callIdomFunction(state, 'elementClose', [t.stringLiteral(el.name)]));
    }
}

function addDynamicAttributeCalls(state, path, dynamicAttributeExpressions, replacements) {
    var i = 0;
    var attrFn = t.identifier(state.addImportFrom('melody-idom', 'attr'));
    for (var len = dynamicAttributeExpressions.length; i < len; i++) {
        var scope = path.scope;
        var indexName = scope.generateUid('i');
        var localIterableName = scope.generateUid('a');
        var lengthName = scope.generateUid('len');

        scope.registerBinding(indexName, path, 'var');
        scope.registerBinding(localIterableName, path, 'var');
        scope.registerBinding(lengthName, path, 'var');

        replacements.push(dynamicAttributes({
            ATTR: attrFn,
            INDEX: t.identifier(indexName),
            LOCAL_ITERABLE: t.identifier(localIterableName),
            LENGTH: t.identifier(lengthName),
            ITERABLE: dynamicAttributeExpressions[i]
        }));
    }
}

function elementOpen(state, openType, name, key, staticId, attributes) {
    return t.callExpression(t.identifier(state.addImportFrom('melody-idom', openType)), [t.stringLiteral(name), key, staticId].concat(attributes));
}

function openElementWithoutAttributes(state, openType, name) {
    return callIdomFunction(state, openType, [t.stringLiteral(name), t.nullLiteral(), t.nullLiteral()]);
}

function callIdomFunction(state, name, args) {
    return t.expressionStatement(t.callExpression(t.identifier(state.addImportFrom('melody-idom', name)), args));
}

function closeElement(state, ref, replacements, el) {
    if (ref) {
        replacements.push(callIdomFunction(state, 'ref', [ref]));
    }
    if (el.children) {
        replacements.push.apply(replacements, el.children);
    }
    replacements.push(callIdomFunction(state, 'elementClose', [t.stringLiteral(el.name)]));
}

function dynamicAttributes(ctx) {
    return {
        type: 'ForStatement',
        init: {
            type: 'VariableDeclaration',
            declarations: [{
                type: 'VariableDeclarator',
                id: ctx.INDEX,
                init: {
                    type: 'NumericLiteral',
                    extra: {
                        rawValue: 0,
                        raw: '0'
                    },
                    value: 0
                }
            }, {
                type: 'VariableDeclarator',
                id: ctx.LOCAL_ITERABLE,
                init: {
                    type: 'ConditionalExpression',
                    test: {
                        type: 'LogicalExpression',
                        left: {
                            type: 'BinaryExpression',
                            left: {
                                type: 'Identifier',
                                name: 'process.env.NODE_ENV'
                            },
                            operator: '===',
                            right: {
                                type: 'StringLiteral',
                                extra: {
                                    rawValue: 'production',
                                    raw: '"production"'
                                },
                                value: 'production'
                            }
                        },
                        operator: '||',
                        right: {
                            type: 'CallExpression',
                            callee: {
                                type: 'MemberExpression',
                                object: {
                                    type: 'Identifier',
                                    name: 'Array'
                                },
                                property: {
                                    type: 'Identifier',
                                    name: 'isArray'
                                },
                                computed: false
                            },
                            arguments: [{
                                type: 'UnaryExpression',
                                operator: '',
                                prefix: false,
                                argument: ctx.ITERABLE
                            }]
                        }
                    },
                    consequent: {
                        type: 'UnaryExpression',
                        operator: '',
                        prefix: false,
                        argument: ctx.ITERABLE
                    },
                    alternate: {
                        type: 'CallExpression',
                        callee: {
                            type: 'ArrowFunctionExpression',
                            id: null,
                            generator: false,
                            expression: false,
                            async: false,
                            params: [],
                            body: {
                                type: 'BlockStatement',
                                body: [{
                                    type: 'ThrowStatement',
                                    argument: {
                                        type: 'NewExpression',
                                        callee: {
                                            type: 'Identifier',
                                            name: 'Error'
                                        },
                                        arguments: [{
                                            type: 'BinaryExpression',
                                            left: {
                                                type: 'BinaryExpression',
                                                left: {
                                                    type: 'StringLiteral',
                                                    extra: {
                                                        rawValue: 'Dynamic attributes have to be an array, found ',
                                                        raw: '"Dynamic attributes have to be an array, found "'
                                                    },
                                                    value: 'Dynamic attributes have to be an array, found '
                                                },
                                                operator: '+',
                                                right: {
                                                    type: 'UnaryExpression',
                                                    operator: 'typeof',
                                                    prefix: true,
                                                    argument: ctx.ITERABLE
                                                }
                                            },
                                            operator: '+',
                                            right: {
                                                type: 'StringLiteral',
                                                extra: {
                                                    rawValue: ' instead',
                                                    raw: '" instead"'
                                                },
                                                value: ' instead'
                                            }
                                        }]
                                    }
                                }],
                                directives: []
                            }
                        },
                        arguments: []
                    }
                }
            }, {
                type: 'VariableDeclarator',
                id: ctx.LENGTH,
                init: {
                    type: 'MemberExpression',
                    object: ctx.LOCAL_ITERABLE,
                    property: {
                        type: 'Identifier',
                        name: 'length'
                    },
                    computed: false
                }
            }],
            kind: 'let'
        },
        test: {
            type: 'BinaryExpression',
            left: ctx.INDEX,
            operator: '<',
            right: ctx.LENGTH
        },
        update: {
            type: 'AssignmentExpression',
            operator: '+=',
            left: ctx.INDEX,
            right: {
                type: 'NumericLiteral',
                extra: {
                    rawValue: 2,
                    raw: '2'
                },
                value: 2
            }
        },
        body: {
            type: 'BlockStatement',
            body: [{
                type: 'ExpressionStatement',
                expression: {
                    type: 'CallExpression',
                    callee: ctx.ATTR,
                    arguments: [{
                        type: 'MemberExpression',
                        object: ctx.LOCAL_ITERABLE,
                        property: ctx.INDEX,
                        computed: true
                    }, {
                        type: 'MemberExpression',
                        object: ctx.LOCAL_ITERABLE,
                        property: {
                            type: 'BinaryExpression',
                            left: ctx.INDEX,
                            operator: '+',
                            right: {
                                type: 'NumericLiteral',
                                extra: {
                                    rawValue: 1,
                                    raw: '1'
                                },
                                value: 1
                            }
                        },
                        computed: true
                    }]
                }
            }],
            directives: []
        }
    };
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var index = {
    visitors: [idomVisitor, mountVisitor],
    filterMap: {
        raw: function raw(path) {
            if (path.parentPath.is('PrintStatement')) {
                path.replaceWithJS(t.expressionStatement(t.callExpression(t.identifier(path.state.addImportFrom('melody-idom', 'raw')), [path.get('target').node])));
            } else {
                path.replaceWithJS(t.callExpression(t.identifier(path.state.addImportFrom('melody-idom', 'rawString')), [path.get('target').node]));
            }
        }
    }
};

module.exports = index;
