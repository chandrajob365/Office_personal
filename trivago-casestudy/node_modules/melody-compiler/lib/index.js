'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var melodyParser = require('melody-parser');
var melodyTraverse = require('melody-traverse');
var melodyTypes = require('melody-types');
require('melody-extension-core');
var t = require('babel-types');
var template = _interopDefault(require('babel-template'));
var _isFunction = _interopDefault(require('lodash/isFunction'));
var _isString = _interopDefault(require('lodash/isString'));
var _camelCase = _interopDefault(require('lodash/camelCase'));
var codeFrame = _interopDefault(require('melody-code-frame'));
var path = require('path');
var random = require('random-seed');
var generate = _interopDefault(require('babel-generator'));

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Template = function (_Node) {
    _inherits(Template, _Node);

    function Template() {
        var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, Template);

        var _this = _possibleConstructorReturn(this, _Node.call(this));

        _this.parentName = null;
        _this.body = body;
        _this.macros = [];
        _this.blocks = [];
        _this.useImports = [];
        return _this;
    }

    return Template;
}(melodyTypes.Node);
melodyTypes.type(Template, 'Template');
melodyTypes.alias(Template, 'Scope');
melodyTypes.visitor(Template, 'parentName', 'macros', 'blocks', 'useImports', 'body');

var File = function (_Node2) {
    _inherits(File, _Node2);

    function File(fileName, template$$1) {
        _classCallCheck(this, File);

        var _this2 = _possibleConstructorReturn(this, _Node2.call(this));

        _this2.template = template$$1;
        _this2.fileName = fileName;
        return _this2;
    }

    return File;
}(melodyTypes.Node);
melodyTypes.type(File, 'File');
//alias(File, 'Scope');
melodyTypes.visitor(File, 'template');

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*eslint no-unused-vars: "off"*/
var extractTemplateInfo = {
    ExtendsStatement: function ExtendsStatement(path$$1) {
        var parentName = path$$1.node.parentName;
        path$$1.remove();
        this.template.parentName = parentName;
    },
    FlushStatement: function FlushStatement(path$$1) {
        // we don't have any use for flush statements
        path$$1.remove();
    },
    SliceExpression: function SliceExpression(path$$1) {
        path$$1.replaceWith(new melodyTypes.FilterExpression(path$$1.node.target, new melodyTypes.Identifier('slice'), [path$$1.node.start || new melodyTypes.NumericLiteral(0), path$$1.node.end || new melodyTypes.MemberExpression(path$$1.node.target, new melodyTypes.Identifier('length'))]));
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var analyseScope = {
    Template: {
        enter: function enter(path$$1) {
            if (!path$$1.node.parentName) {
                var contextName = path$$1.scope.generateUid('context');
                path$$1.scope.registerBinding(contextName, path$$1, 'param');
                path$$1.scope.contextName = contextName;
            }
        },
        exit: function exit(path$$1) {
            if (path$$1.node.parentName) {
                var body = path$$1.get('body');
                for (var i = 0, len = body.length; i < len; i++) {
                    var stmt = body[i];
                    if (!stmt.is('ContextMutation') && !stmt.is('BlockStatement')) {
                        stmt.remove();
                    }
                }
            }
        }
    },
    Identifier: function Identifier$$1(path$$1) {
        if (this.isReferenceIdentifier(path$$1)) {
            path$$1.scope.reference(path$$1.node.name, path$$1);
        } else if (path$$1.parentPath.is('MacroDeclarationStatement') && path$$1.parentKey == 'arguments') {
            path$$1.scope.registerBinding(path$$1.node.name, path$$1, 'param');
        } else if (path$$1.parentPath.is('CallExpression') && path$$1.parentKey === 'callee') {
            if (this.functionMap[path$$1.node.name]) {
                path$$1.scope.registerBinding(path$$1.node.name, path$$1, 'function');
            } else {
                path$$1.scope.reference(path$$1.node.name, path$$1);
            }
        }
    },
    VariableDeclarationStatement: function VariableDeclarationStatement(path$$1) {
        var varName = path$$1.node.name;
        var previousBinding = path$$1.scope.getBinding(varName.name);
        if (previousBinding && previousBinding.kind === 'var') {
            previousBinding.definitionPaths.push(path$$1);
            previousBinding.mutated = true;
        } else {
            path$$1.scope.registerBinding(varName.name, path$$1, 'var').contextual = true;
            path$$1.scope.mutated = true;
        }
    },

    FromStatement: {
        exit: function exit(path$$1) {
            if (path$$1.get('source').is('Identifier')) {
                if (path$$1.node.source.name === '_self') {
                    path$$1.remove();
                }
            }
        }
    },
    ImportDeclaration: function ImportDeclaration(path$$1) {
        var rootScope = path$$1.scope,
            identifier$$1 = path$$1.node.alias || path$$1.node.key;
        var binding = rootScope.registerBinding(identifier$$1.name, path$$1.node.alias ? path$$1.get('alias') : path$$1.get('key'), 'macro');
        if (path$$1.get('key').is('Identifier') && path$$1.node.key.name !== '_self') {
            binding.setData('Identifier.OriginalName', path$$1.node.key.name);
        }
    },
    MacroDeclarationStatement: function MacroDeclarationStatement(path$$1) {
        var scope = path$$1.scope;
        var rootScope = scope.getRootScope();
        rootScope.registerBinding(path$$1.node.name.name, path$$1.get('name'), 'macro');

        scope.registerBinding('varargs', path$$1, 'param');
    },
    Include: function Include(path$$1) {
        if (path$$1.node.contextFree === false) {
            path$$1.scope.escapesContext = true;
        }
    },
    BlockStatement: function BlockStatement(path$$1) {
        if (this.template.parentName || path$$1.parentPath.is('EmbedStatement')) {
            path$$1.scope.registerBinding('parent', path$$1, 'var');
        }
        path$$1.scope.registerBinding('_context', path$$1, 'param');
        path$$1.scope.contextName = '_context';
        path$$1.parentPath.scope.escapesContext = true;
    },

    Scope: {
        exit: function exit(path$$1) {
            if (path$$1.scope.escapesContext) {
                if (path$$1.scope.parent) {
                    if (!path$$1.scope.parent.escapesContext) {
                        path$$1.scope.parent.escapesContext = true;
                    }
                }
            }
            if (path$$1.scope.mutated && path$$1.scope.escapesContext && path$$1.scope.contextName === '_context') {
                var contextName = path$$1.scope.generateUid('context');
                path$$1.scope.registerBinding(contextName, path$$1, 'const');
                path$$1.scope.contextName = contextName;
            }
        }
    },
    RootScope: {
        exit: function exit(path$$1) {
            if (path$$1.scope.mutated && path$$1.scope.escapesContext && path$$1.scope.contextName === '_context') {
                var contextName = path$$1.scope.generateUid('context');
                path$$1.scope.registerBinding(contextName, path$$1, 'const');
                path$$1.scope.contextName = contextName;
            }
        }
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var analyse = melodyTraverse.merge(analyseScope, extractTemplateInfo);

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var buildRenderFunction = template('\nTEMPLATE.NAME = function(_context) {\n  BODY\n};\n');

var blockConverter = {
    FromStatement: function FromStatement(path$$1) {
        var fromStmt = path$$1.node,
            source = fromStmt.source;
        for (var _iterator = fromStmt.imports, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref2 = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref2 = _i.value;
            }

            var _ref3 = _ref2;
            var key = _ref3.key,
                alias$$1 = _ref3.alias;

            this.addImportFrom(source.value, key.name, alias$$1.name);
        }
        path$$1.remove();
    },

    ImportDeclaration: {
        exit: function exit(path$$1) {
            var _path$node = path$$1.node,
                key = _path$node.key,
                alias$$1 = _path$node.alias;

            var keyPath = path$$1.get('key');
            var parentPath = path$$1.parentPath;
            if (!parentPath.is('MacroDeclaration') && !parentPath.is('Template') && !parentPath.is('BlockStatement')) {
                throw new Error('Import must be used in macro, block or template');
            }
            if (!keyPath.is('StringLiteral')) {
                if (!(keyPath.is('Identifier') && key.name === '_self')) {
                    // todo: proper error reporting
                    throw Error();
                } else {
                    var selfBinding = path$$1.scope.getBinding(path$$1.node.alias.name),
                        macroNames = [];
                    for (var _iterator2 = selfBinding.referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                        var _ref4;

                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref4 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done) break;
                            _ref4 = _i2.value;
                        }

                        var usagePath = _ref4;

                        var boundName = usagePath.parentPath.node.property.name;
                        macroNames.push(t.objectProperty(t.identifier(boundName), t.identifier(boundName), false, true));
                    }
                    path$$1.scope.block.body.unshift(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(selfBinding.identifier), t.objectExpression(macroNames))]));
                }
            } else {
                this.addNamespaceImportFrom(key.value, alias$$1.name);
            }
            path$$1.remove();
        }
    },
    MacroDeclarationStatement: {
        exit: function exit(path$$1) {
            var node = path$$1.node,
                scope = path$$1.scope;

            var args = [].concat(node.arguments);
            if (scope.getBinding('varargs').referenced) {
                args.push(t.restElement(t.identifier('varargs')));
            }
            var macroStmt = t.exportNamedDeclaration(t.functionDeclaration(node.name, args, node.body), []);
            path$$1.remove();
            this.program.body.push(macroStmt);
        }
    },
    UseStatement: function UseStatement(path$$1) {
        var useStmt = path$$1.node,
            source = useStmt.source;
        if (useStmt.aliases.length) {
            var members = [];
            for (var _iterator3 = useStmt.aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref6 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref6 = _i3.value;
                }

                var _ref7 = _ref6;
                var name = _ref7.name,
                    alias$$1 = _ref7.alias;

                var aliasName = toBlockName(alias$$1.name),
                    nameName = toBlockName(name.name);
                this.addImportFrom(source.value, aliasName, nameName);
                members.push(t.objectProperty(t.identifier(aliasName), t.identifier(aliasName), false, true));
            }
            var inheritBlocks = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [t.identifier(this.templateVariableName), t.objectExpression(members)]));
            this.program.body.push(inheritBlocks);
        } else {
            var name = this.addDefaultImportFrom(source.value, path$$1.scope.generateUid('use'));
            this.program.body.push(t.expressionStatement(t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'inheritBlocks')), [t.identifier(this.templateVariableName), t.identifier(name)])));
        }
        path$$1.remove();
    },

    CallExpression: {
        exit: function exit(path$$1) {
            var callee = path$$1.get('callee');
            if (callee.is('Identifier') && callee.node.name === 'block') {
                path$$1.replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('this'), t.identifier(toBlockName(path$$1.get('arguments')[0].node.value))), [t.identifier(path$$1.scope.contextName)])));
            } else if (callee.is('MemberExpression') && callee.get('object').is('Identifier')) {
                var name = callee.get('object').node.name;
                var binding = path$$1.scope.getBinding(name);
                if (binding && binding.kind === 'macro') {
                    path$$1.replaceWithJS(t.expressionStatement(path$$1.node));
                }
            }
        }
    },
    BlockCallExpression: {
        exit: function exit(path$$1) {
            var node = path$$1.node;
            var callExpression$$1 = t.callExpression(t.memberExpression(t.identifier('this'), t.identifier(toBlockName(node.callee.name)), true), [t.identifier(path$$1.scope.contextName)]);
            path$$1.replaceWith(new melodyTypes.Fragment(callExpression$$1));
        }
    },
    BlockStatement: {
        exit: function exit(path$$1) {
            if (path$$1.parentPath.is('EmbedStatement')) {
                // todo implement
            } else {
                var node = path$$1.node,
                    blockName = toBlockName(node.name.name);

                var blockScope = path$$1.scope;
                if (blockScope.hasBinding('parent')) {
                    var bindings = blockScope.getBinding('parent');
                    for (var _iterator4 = bindings.referencePaths, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                        var _ref8;

                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref8 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done) break;
                            _ref8 = _i4.value;
                        }

                        var ref = _ref8;

                        ref.replaceWithJS(t.memberExpression(t.identifier(this.parentName), t.identifier(blockName)));
                    }
                }
                if (this.template.parentName && !path$$1.findParentPathOfType('BlockStatement')) {
                    // if we're in an inherited template and are not defined in
                    // another block statement
                    path$$1.remove();
                } else {
                    var callExpression$$1 = t.callExpression(t.memberExpression(t.identifier('this'), t.identifier(blockName)), [t.identifier(path$$1.parentPath.scope.contextName)]);
                    path$$1.replaceWith(new melodyTypes.Fragment(callExpression$$1));
                }
                this.program.body.push(buildRenderFunction({
                    TEMPLATE: t.identifier(this.templateVariableName),
                    NAME: t.identifier(blockName),
                    BODY: node.body
                }));
            }
        }
    },
    IncludeStatement: {
        exit: function exit(path$$1) {
            var includeName = this.addDefaultImportFrom(path$$1.node.source.value, path$$1.scope.generateUid('include'));
            path$$1.scope.getRootScope().registerBinding(includeName);

            var node = path$$1.node;
            var argument = void 0;

            if (node.argument) {
                if (node.contextFree) {
                    argument = node.argument;
                } else {
                    argument = t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'createSubContext')), [t.identifier(path$$1.scope.contextName), node.argument]);
                }
            } else if (!node.contextFree) {
                argument = t.identifier(path$$1.scope.contextName);
            }

            var includeCall = t.callExpression(t.identifier(includeName), argument ? [argument] : []);
            path$$1.replaceWith(new melodyTypes.Fragment(includeCall));
        }
    },
    EmbedStatement: {
        exit: function exit(path$$1) {
            // todo: if template has parent, check that we're in a block
            var rootScope = path$$1.scope.getRootScope();
            var embedName = rootScope.generateUid('embed');
            var importDecl = t.importDeclaration([t.importSpecifier(t.identifier(embedName), t.identifier('_template'))], path$$1.node.parent);
            this.program.body.splice(0, 0, importDecl);
            rootScope.registerBinding(embedName);

            var embeddedName = rootScope.generateUid('embed');
            rootScope.registerBinding(embeddedName);
            var lastStmt = this.insertGlobalVariableDeclaration('const', t.identifier(embeddedName), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('create')), [t.identifier(embedName)]));
            if (path$$1.get('blocks')) {
                for (var _iterator5 = path$$1.get('blocks'), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                    var _ref9;

                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref9 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done) break;
                        _ref9 = _i5.value;
                    }

                    var blockPath = _ref9;

                    var block = blockPath.node;
                    var blockName = 'render' + block.name.name[0].toUpperCase() + block.name.name.substring(1);
                    var stmt = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier(embeddedName), t.identifier(blockName)), {
                        type: 'FunctionExpression',
                        id: null,
                        generator: false,
                        expression: false,
                        params: [t.identifier('_context')],
                        body: t.blockStatement(block.body)
                    }));
                    lastStmt = this.insertAfter(stmt, lastStmt);

                    var blockScope = blockPath.scope;
                    if (blockScope.hasBinding('parent')) {
                        var bindings = blockScope.getBinding('parent');
                        for (var _iterator6 = bindings.referencePaths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                            var _ref10;

                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref10 = _iterator6[_i6++];
                            } else {
                                _i6 = _iterator6.next();
                                if (_i6.done) break;
                                _ref10 = _i6.value;
                            }

                            var ref = _ref10;

                            ref.replaceWithJS(t.memberExpression(t.identifier(embedName), t.identifier(blockName)));
                        }
                    }
                }
            }
            var context = t.identifier(path$$1.scope.contextName);
            if (path$$1.node.argument) {
                if (path$$1.node.contextFree) {
                    context = t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'createSubContext')), [context, path$$1.node.argument]);
                } else {
                    context = t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'createSubContext')), [context, path$$1.node.argument]);
                }
            }

            var callExpression$$1 = t.callExpression(t.memberExpression(t.identifier(embeddedName), t.identifier('render')), [context]);

            path$$1.replaceWith(new melodyTypes.Fragment(callExpression$$1));
        }
    }
};

function toBlockName(name) {
    return 'render' + name[0].toUpperCase() + name.substring(1);
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var operatorMap = {
    or: '||',
    and: '&&',
    'b-or': '|',
    'b-xor': '^',
    'b-and': '&'
};

var expressionConverter = {
    UnaryNotExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.unaryExpression('!', path$$1.node.argument));
        }
    },
    UnaryExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.unaryExpression(path$$1.node.operator, path$$1.get('argument').node));
        }
    },
    BinaryConcatExpression: {
        exit: function exit(path$$1) {
            var node = path$$1.node;
            path$$1.replaceWithJS({
                type: 'BinaryExpression',
                operator: '+',
                left: node.left,
                right: node.right
            });
        }
    },
    BinaryPowerExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.memberExpression(t.identifier('Math'), t.identifier('pow')), [path$$1.get('left').node, path$$1.get('right').node]));
        }
    },
    BinaryNullCoalesceExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.conditionalExpression(t.binaryExpression('!=', path$$1.get('left').node, t.nullLiteral()), path$$1.get('left').node, path$$1.get('right').node));
        }
    },
    BinaryFloorDivExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'round')), [t.binaryExpression('/', path$$1.get('left').node, path$$1.get('right').node), t.numericLiteral(0), t.stringLiteral('floor')]));
        }
    },
    BinaryNotInExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.unaryExpression('!', t.callExpression(t.identifier(this.addImportFrom('lodash', 'includes')), [path$$1.get('right').node, path$$1.get('left').node])));
        }
    },
    BinaryInExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom('lodash', 'includes')), [path$$1.get('right').node, path$$1.get('left').node]));
        }
    },
    BinaryStartsWithExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom('lodash', 'startsWith')), [path$$1.get('left').node, path$$1.get('right').node]));
        }
    },
    BinaryEndsWithExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom('lodash', 'endsWith')), [path$$1.get('left').node, path$$1.get('right').node]));
        }
    },
    BinaryRangeExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom('lodash', 'range')), [path$$1.get('left').node, path$$1.get('right').node]));
        }
    },
    BinaryMatchesExpression: {
        exit: function exit(path$$1) {
            var right = path$$1.get('right'),
                pattern = right.is('StringLiteral') ? t.regExpLiteral(right.node.value) : right.node;
            path$$1.replaceWithJS(t.unaryExpression('!', t.unaryExpression('!', t.callExpression(t.memberExpression(path$$1.get('left').node, t.identifier('match')), [pattern]))));
        }
    },
    BinaryExpression: {
        exit: function exit(path$$1) {
            var node = path$$1.node;
            path$$1.replaceWithJS({
                type: 'BinaryExpression',
                operator: operatorMap[node.operator] || node.operator,
                left: node.left,
                right: node.right
            });
        }
    },
    CallExpression: {
        exit: function exit(path$$1) {
            var callee = path$$1.get('callee');
            if (callee.is('Identifier')) {
                var functionName = callee.node.name,
                    binding = callee.scope.getBinding(functionName);
                if (binding) {
                    if (binding.kind === 'macro' && path$$1.parentPath.is('PrintStatement')) {
                        path$$1.parentPath.replaceWith(new melodyTypes.Fragment(t.callExpression(t.identifier(functionName), path$$1.node.arguments)));
                    } else if (binding.kind === 'function') {
                        var functionSource = this.functionMap[functionName];
                        if (_isString(functionSource)) {
                            callee.node.name = this.addImportFrom(functionSource, functionName);
                        } else if (_isFunction(functionSource)) {
                            functionSource(path$$1);
                        }
                    }
                }
            }
        }
    },
    ConditionalExpression: {
        exit: function exit(path$$1) {
            var node = path$$1.node;
            if (!node.alternate) {
                node.alternate = t.stringLiteral('');
            } else if (!node.consequent) {
                path$$1.replaceWithJS({
                    type: 'LogicalExpression',
                    operator: '||',
                    left: node.test,
                    right: node.alternate
                });
            }
        }
    },
    SequenceExpression: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS({
                type: 'BlockStatement',
                body: path$$1.node.expressions
            });
        }
    },
    DoStatement: {
        exit: function exit(path$$1) {
            path$$1.replaceWithJS(t.expressionStatement(path$$1.node.value));
        }
    },
    BinaryAndExpression: {
        exit: function exit(path$$1) {
            path$$1.node.operator = '&&';
        }
    },
    BinaryOrExpression: {
        exit: function exit(path$$1) {
            path$$1.node.operator = '||';
        }
    },
    FilterExpression: {
        exit: function exit(path$$1) {
            var expr = path$$1.node,
                filterSource = this.filterMap[expr.name.name];
            if (!filterSource) {
                return;
            }
            if (_isString(filterSource)) {
                path$$1.replaceWithJS(t.callExpression(t.identifier(this.addImportFrom(filterSource, expr.name.name)), [expr.target].concat(expr.arguments)));
            } else if (_isFunction(filterSource)) {
                filterSource.call(this, path$$1);
            }
        }
    },
    IfStatement: {
        exit: function exit(path$$1) {
            path$$1.node.consequent = t.blockStatement(path$$1.node.consequent);
            if (path$$1.node.alternate && Array.isArray(path$$1.node.alternate)) {
                path$$1.node.alternate = t.blockStatement(path$$1.node.alternate);
            }
        }
    },
    VariableDeclarationStatement: {
        exit: function exit(path$$1) {
            var node = path$$1.node;
            var binding = path$$1.scope.getBinding(node.name.name);
            if (path$$1.scope.escapesContext || binding && binding.shadowedBinding) {
                path$$1.replaceWithJS(t.assignmentExpression('=', t.memberExpression(t.identifier(path$$1.scope.contextName), node.name), node.value));
            } else {
                path$$1.replaceWithJS(t.assignmentExpression('=', node.name, node.value));
            }
        }
    },
    SetStatement: {
        exit: function exit(path$$1) {
            var assignments = [];
            var replacements = [];
            for (var _iterator = path$$1.node.assignments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var expr = _ref;

                if (t.isAssignmentExpression) {
                    assignments.push(expr);
                } else {
                    // todo better error handling
                    throw new Error('Must be variable declaration or assignment');
                }
            }
            if (assignments.length) {
                replacements.push.apply(replacements, path$$1.node.assignments.map(function (expr) {
                    return t.expressionStatement(expr);
                }));
            }
            path$$1.replaceWithMultipleJS.apply(path$$1, replacements);
        }
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Not using lodash capitalize here, because it makes the rest of the string lowercase
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function getDisplayName(str) {
    return capitalize(_camelCase(str));
}

function buildRenderFunction$1(ctx) {
    return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(ctx.TEMPLATE, ctx.NAME), t.functionExpression(null, [t.identifier('_context')], t.blockStatement(ctx.BODY))));
}

var templateConverter = {
    Identifier: {
        exit: function exit(path$$1) {
            if (!this.isReferenceIdentifier(path$$1)) {
                return;
            }
            var binding = path$$1.scope.getBinding(path$$1.node.name),
                contextName = void 0;
            if (binding) {
                var originalName = binding.getData('Identifier.OriginalName');
                if (originalName) {
                    path$$1.node.name = originalName;
                }
                if (binding.getData('ImportDeclaration.ImportFromSelf')) {
                    path$$1.parentPath.replaceWith(path$$1.parent.property);
                } else if (binding.kind === 'context') {
                    contextName = path$$1.getData('Identifier.contextName') || binding.scope.contextName || path$$1.scope.contextName;
                } else if (binding.kind === 'var' && binding.scope.escapesContext && binding.contextual) {
                    if (binding.shadowedBinding) {
                        binding = binding.getRootDefinition();
                    }
                    contextName = path$$1.getData('Identifier.contextName') || binding.scope.contextName || path$$1.scope.contextName;
                }
            }
            if (contextName) {
                var replacement = t.memberExpression(t.identifier(contextName), t.identifier(path$$1.node.name));
                path$$1.replaceWithJS(replacement);
            }
        }
    },
    PrintStatement: {
        enter: function enter(path$$1) {
            // remove empty print statements
            // todo should we really do this?
            var value = path$$1.get('value');
            if (value.is('StringLiteral')) {
                // if(value.node.value.trim() === '') {
                if (value.node.value.match(/^\s*$/)) {
                    path$$1.remove();
                    return;
                } else if (this.isInSpaceless() && Array.isArray(path$$1.container) && Number.isInteger(path$$1.key)) {
                    if (path$$1.key === 0) {
                        value.node.value = value.node.value.replace(/^\s+/, '');
                    }
                    if (path$$1.key === path$$1.container.length - 1) {
                        value.node.value = value.node.value.replace(/\s+$/, '');
                    }
                }
                value.node.value = value.node.value.replace(/^\s{2,}|\s{2,}$/g, ' ');
            }
        }
    },
    SpacelessBlock: {
        enter: function enter() {
            this.enterSpaceless();
        },
        exit: function exit(path$$1) {
            this.exitSpaceless();
            path$$1.replaceWithMultipleJS.apply(path$$1, path$$1.node.body);
        }
    },
    RootScope: {
        enter: function enter(path$$1) {
            // handle "import _self as t;"
            var scope = path$$1.scope.getRootScope();
            var localMacroImportUsages = void 0;
            for (var _iterator = Object.keys(path$$1.scope.getRootScope().bindings), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var identifier$$1 = _ref;

                var binding = scope.getBinding(identifier$$1);
                if (binding && binding.kind === 'macro' && binding.getData('ImportDeclaration.ImportFromSelf')) {
                    localMacroImportUsages = binding;
                    break;
                }
            }
            if (localMacroImportUsages && localMacroImportUsages.referenced) {
                for (var _iterator2 = localMacroImportUsages.referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var usage = _ref2;

                    if (usage.parentPath.is('MemberExpression')) {
                        usage.parentPath.replaceWith(usage.parent.property);
                    }
                }
            }
        },
        exit: function exit(path$$1) {
            if (path$$1.scope.mutated && path$$1.scope.escapesContext) {
                path$$1.node.body.unshift(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(path$$1.scope.contextName), t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'createSubContext')), [t.identifier('_context')]))]));
            }
        }
    },
    Scope: {
        exit: function exit(path$$1) {
            insertVariableDeclarations(path$$1);
        }
    },
    Template: {
        enter: function enter(path$$1) {
            // create general structure of template
            this.templateVariableName = '_template';
            path$$1.scope.registerBinding(this.templateVariableName);
            var fileName = this.file.fileName || '<unknown>';

            var fileParts = fileName.split('/');
            var name = fileParts.pop().split('.')[0];

            if (name === 'index' || name === 'base') {
                fileName = getDisplayName(fileParts.pop());
            } else {
                fileName = getDisplayName(name);
            }
            this.fileName = this.generateUid(fileName);
            this.markIdentifier(this.fileName);

            if (path$$1.node.parentName) {
                this.parentName = path$$1.scope.generateUid('parent');
                path$$1.scope.registerBinding(this.parentName);
                this.program.body.splice(0, 0, t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(this.templateVariableName), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('create')), [t.identifier(this.parentName)]))]), []));
                if (path$$1.node.body.length) {
                    path$$1.node.body.push(new melodyTypes.Fragment(t.callExpression(t.memberExpression(t.memberExpression(t.identifier(this.parentName), t.identifier('render')), t.identifier('call')), [t.identifier(this.templateVariableName), t.identifier(path$$1.scope.contextName)])));
                }
            } else {
                this.program.body.splice(0, 0, t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(this.templateVariableName), t.objectExpression([]))]), []));
            }
            path$$1.replaceWith(path$$1.node);
        },
        exit: function exit(path$$1) {
            if (path$$1.scope.mutated && path$$1.scope.escapesContext) {
                path$$1.node.body.unshift(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(path$$1.scope.contextName), t.callExpression(t.identifier(this.addImportFrom('melody-runtime', 'createSubContext')), [t.identifier('_context')]))]));
            }
            insertVariableDeclarations(path$$1);
            var fileName = this.fileName;

            if (!path$$1.node.parentName) {
                this.program.body.push(buildRenderFunction$1({
                    TEMPLATE: t.identifier(this.templateVariableName),
                    NAME: t.identifier('render'),
                    BODY: path$$1.node.body
                }));
            } else {
                var parentName = this.parentName;
                var importDecl = t.importDeclaration([t.importSpecifier(t.identifier(parentName), t.identifier('_template'))], path$$1.node.parentName);
                this.program.body.splice(0, 0, importDecl);
                var body = path$$1.get('body').map(function (e) {
                    return e.node;
                });
                if (body.length) {
                    var renderFunction = buildRenderFunction$1({
                        TEMPLATE: t.identifier(this.templateVariableName),
                        NAME: t.identifier('render'),
                        BODY: body
                    });
                    this.program.body.push(renderFunction);
                }
            }
            this.program.body.push(t.ifStatement(t.binaryExpression('!==', t.memberExpression(t.memberExpression(t.identifier('process'), t.identifier('env')), t.identifier('NODE_ENV')), t.stringLiteral('production')), t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier(this.templateVariableName), t.identifier('displayName')), t.stringLiteral(fileName)))])));
            this.program.body.push(t.exportDefaultDeclaration(t.functionDeclaration(t.identifier(fileName), [t.identifier('props')], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.identifier(this.templateVariableName), t.identifier('render')), [t.identifier('props')]))]))
            //t.identifier(this.templateVariableName),
            ));
            path$$1.replaceWithJS(this.program);
        }
    }
};

function insertVariableDeclarations(path$$1) {
    var bindings = path$$1.scope.bindings,
        varDeclarations = [];
    for (var name in bindings) {
        var binding = bindings[name];
        if (binding && binding.contextual && !binding.scope.escapesContext && !binding.shadowedBinding) {
            varDeclarations.push(t.variableDeclarator(t.identifier(name)));
        }
    }
    if (varDeclarations.length) {
        var body = path$$1.node.body;
        if (body && body.body) {
            body = body.body;
        }
        if (!body) {
            body = path$$1.node.expressions;
        }
        if (!body) {
            body = [];
        }
        //const body = (path.node.body && path.node.body.body) || path.node.expressions || [];
        body.unshift(t.variableDeclaration('let', varDeclarations));
    }
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var convert = melodyTraverse.merge(templateConverter, expressionConverter, blockConverter);

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var State = function () {
    function State(file$$1, source) {
        _classCallCheck$1(this, State);

        this.file = file$$1;
        this.source = source;
        this.template = file$$1.template;
        this.options = {
            generateKey: true,
            projectRoot: undefined,
            // eslint-disable-next-line
            warn: console.warn.bind(console),
            // eslint-disable-next-line
            error: console.error.bind(console)
        };
        this.program = {
            type: 'Program',
            body: [],
            sourceType: 'module'
        };
        this._importCache = Object.create(null);
        this.filterMap = Object.create(null);
        this.functionMap = Object.create(null);
        this._usedIdentifiers = Object.create(null);
        this._spacelessStack = [];
    }

    State.prototype.generateKey = function generateKey() {
        if (this.keyGenerator === undefined) {
            this.keyGenerator = createKeyGenerator(this.file.fileName, this.options.projectRoot || process.cwd());
        }
        return this.keyGenerator.generate();
    };

    State.prototype.enterSpaceless = function enterSpaceless() {
        this._spacelessStack.push(true);
    };

    State.prototype.exitSpaceless = function exitSpaceless() {
        this._spacelessStack.pop();
    };

    State.prototype.isInSpaceless = function isInSpaceless() {
        return !!this._spacelessStack[this._spacelessStack.length - 1];
    };

    State.prototype.error = function error(message, pos, advice) {
        var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        var errorMessage = message + '\n';
        errorMessage += codeFrame({
            rawLines: this.source,
            lineNumber: pos.line,
            colNumber: pos.column,
            length: length
        });
        if (advice) {
            errorMessage += '\n\n' + advice;
        }
        throw new Error(errorMessage);
    };

    State.prototype.warn = function warn(message, pos, advice) {
        var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        var warnMessage = message + '\n';
        warnMessage += codeFrame({
            rawLines: this.source,
            lineNumber: pos.line,
            colNumber: pos.column,
            length: length
        });
        if (advice) {
            warnMessage += '\n\n' + advice;
        }
        this.options.warn(warnMessage);
    };

    State.prototype.markIdentifier = function markIdentifier(name) {
        this._usedIdentifiers[name] = true;
    };

    State.prototype.generateUid = function generateUid() {
        var nameHint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'temp';

        var name = toIdentifier(nameHint);

        var uid = void 0;
        var i = 0;
        do {
            uid = _generateUid(name, i);
            i++;
        } while (this._usedIdentifiers[uid]);

        return uid;
    };

    State.prototype.generateComponentUid = function generateComponentUid() {
        var nameHint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'temp';

        var name = toIdentifier(nameHint);

        var uid = void 0;
        var i = 0;
        do {
            uid = _generateComponentUid(name, i);
            i++;
        } while (this._usedIdentifiers[uid]);

        return uid;
    };

    State.prototype.getImportFrom = function getImportFrom(source) {
        if (this._importCache[source]) {
            return this._importCache[source];
        }

        var body = this.program.body;
        var i = 0;
        for (var len = body.length; i < len; i++) {
            var stmt = body[i];
            if (stmt.type === 'ImportDeclaration') {
                if (stmt.source.value === source) {
                    this._importCache[source] = stmt;
                    return stmt;
                }
            }
        }
        return null;
    };

    State.prototype.addNamespaceImportFrom = function addNamespaceImportFrom(source, alias$$1) {
        var body = this.program.body;
        var i = 0;
        for (var len = body.length; i < len; i++) {
            var stmt = body[i];
            if (stmt.type === 'ImportDeclaration') {
                if (stmt.source.value === source) {
                    if (stmt.specifiers.length === 1) {
                        var specifier = stmt.specifiers[0];
                        if (specifier.type === 'ImportNamespaceSpecifier' && specifier.local.name === alias$$1) {
                            return stmt;
                        }
                    }
                }
            }
        }
        var importDeclaration$$1 = t.importDeclaration([t.importNamespaceSpecifier(t.identifier(alias$$1))], t.stringLiteral(source));
        this.program.body.splice(0, 0, importDeclaration$$1);
        return importDeclaration$$1;
    };

    State.prototype.addImportFrom = function addImportFrom(source, identifier$$1) {
        var local = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.generateUid(identifier$$1);

        var importDecl = this.getImportFrom(source);
        if (importDecl) {
            var i = 0;
            var isNamespaceImport = false;
            for (var specs = importDecl.specifiers, len = specs.length; i < len; i++) {
                var spec = specs[i];
                if (spec.type === 'ImportSpecifier' && spec.imported && spec.imported.name === identifier$$1) {
                    // already imported it
                    return spec.local.name;
                } else if (spec.type === 'ImportNamespaceSpecifier') {
                    isNamespaceImport = true;
                    break;
                }
            }

            if (!isNamespaceImport) {
                importDecl.specifiers.push(t.importSpecifier(t.identifier(local), t.identifier(identifier$$1)));
                return local;
            }
        }

        importDecl = t.importDeclaration([t.importSpecifier(t.identifier(local), t.identifier(identifier$$1))], t.stringLiteral(source));
        this._importCache[source] = importDecl;
        this.program.body.splice(0, 0, importDecl);
        return local;
    };

    State.prototype.addDefaultImportFrom = function addDefaultImportFrom(source) {
        var local = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.generateUid();

        var importDecl = this.getImportFrom(source);
        if (!importDecl) {
            importDecl = t.importDeclaration([t.importDefaultSpecifier(t.identifier(local))], t.stringLiteral(source));
            this._importCache[source] = importDecl;
            this.program.body.splice(0, 0, importDecl);
        } else {
            if (importDecl.specifiers[0].type === 'ImportDefaultSpecifier') {
                return importDecl.specifiers[0].local.name;
            }
            importDecl.specifiers.unshift(t.importDefaultSpecifier(t.identifier(local)));
        }
        return local;
    };

    State.prototype.ensureImportFrom = function ensureImportFrom(source) {
        var importDecl = this.getImportFrom(source);
        if (!importDecl) {
            importDecl = t.importDeclaration([], t.stringLiteral(source));
            this._importCache[source] = importDecl;
            this.program.body.splice(0, 0, importDecl);
        }
    };

    State.prototype.insertGlobalVariableDeclaration = function insertGlobalVariableDeclaration(kind, id, init) {
        var decl = t.variableDeclarator(id, init);
        for (var _iterator = this.program.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var _stmt = _ref;

            if (_stmt.type === 'VariableDeclaration' && _stmt.kind === kind) {
                _stmt.declarations.push(decl);
                return _stmt;
            }
        }
        var stmt = t.variableDeclaration(kind, [decl]);
        this.program.body.push(stmt);
        return stmt;
    };

    State.prototype.insertAfter = function insertAfter(stmt, sibling) {
        var index = this.program.body.indexOf(sibling);
        this.program.body.splice(index + 1, 0, stmt);
        return stmt;
    };

    State.prototype.insertBefore = function insertBefore(stmt, sibling) {
        var index = this.program.body.indexOf(sibling);
        this.program.body.splice(index, 0, stmt);
        return stmt;
    };

    State.prototype.isReferenceIdentifier = function isReferenceIdentifier(path$$1) {
        var parentPath = path$$1.parentPath,
            key = path$$1.parentKey;

        if (parentPath.is('MemberExpression') && key === 'property' && !parentPath.node.computed) {
            return false;
        }

        if (parentPath.is('NamedArgumentExpression')) {
            return false;
        }

        if (parentPath.is('MountStatement') && key === 'name' && parentPath.node.source) {
            return false;
        }

        if (parentPath.is('ObjectProperty') && key === 'key' && !parentPath.node.computed) {
            return false;
        }

        if (parentPath.is('Attribute') && key !== 'value') {
            return false;
        }

        if (parentPath.is('BlockStatement') && key === 'name') {
            return false;
        }

        if (parentPath.is('ForStatement') && (key === 'keyTarget' || key === 'valueTarget')) {
            return false;
        }

        if (parentPath.is('ImportDeclaration') || parentPath.is('AliasExpression')) {
            return false;
        }

        if (parentPath.is('MacroDeclarationStatement') && (key === 'name' || key === 'arguments')) {
            return false;
        }

        if (parentPath.is('VariableDeclarationStatement') && key === 'name') {
            return false;
        }

        if (parentPath.is('CallExpression') && key === 'callee') {
            return false;
        }

        return true;
    };

    return State;
}();

function toIdentifier(nameHint) {
    var name = nameHint + '';
    name = name.replace(/[^a-zA-Z0-9$_]/g, '');

    name = name.replace(/^[-0-9]+/, '');
    name = name.replace(/[-\s]+(.)?/, function (match, c) {
        return c ? c.toUpperCase() : '';
    });

    name = name.replace(/^_+/, '').replace(/[0-9]+$/, '');
    return name;
}

function _generateUid(name, i) {
    if (i > 0) {
        return name + '$' + i;
    }
    return name;
}

function capitalize$1(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function _generateComponentUid(name, i) {
    var finalName = capitalize$1(name);
    if (i > 0) {
        return finalName + '$' + i;
    }
    return finalName;
}

/**
 * If filename is not defined, generates random keys based on Math.random.
 * Otherwise, uses filename as a seed for deterministic keys. Filename is
 * converted to a relative path based on `projectRoot`.
 */
function createKeyGenerator(filename, projectRoot) {
    // if filename is not defined, generate random keys
    // based on Math.random
    // otherwise, use filename as a seed for deterministic keys
    var relativePath = filename ? path.relative(projectRoot, filename) : undefined;

    var generator = random.create(relativePath);
    return {
        generate: function generate$$1() {
            var i = void 0;
            var s = '';
            // 7 chars long keys
            for (i = 0; i < 7; i++) {
                // start from 33th ASCII char (!), skipping quote ("), ampersand (&)
                // and backslash (\)
                // math: 33 + 91 + 3 = 127, 126 (tilde ~) is the last char we allow
                // where 3 is number of chars we skip between 33-127

                var rand = 33 + generator(91);
                // skip quote (")
                if (rand >= 34) {
                    rand++;
                }
                // skip ampersand (&)
                if (rand >= 38) {
                    rand++;
                }
                // skip backslash (\)
                if (rand >= 92) {
                    rand++;
                }
                s += String.fromCharCode(rand);
            }
            return s;
        }
    };
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function throwMissingMelodyPluginError(path$$1) {
    this.error('Missing melody plugin', 0, 'Cannot convert templates, since there seems to be no melody plugin to convert the template to a certain output format. You can choose for example between `melody-plugin-idom` and `melody-plugin-jsx`.');
}

var validate = {
    Element: {
        exit: function exit(path$$1) {
            throwMissingMelodyPluginError.call(this, path$$1);
        }
    },
    Fragment: {
        exit: function exit(path$$1) {
            throwMissingMelodyPluginError.call(this, path$$1);
        }
    },
    PrintStatement: {
        exit: function exit(path$$1) {
            throwMissingMelodyPluginError.call(this, path$$1);
        }
    },
    FilterExpression: {
        exit: function exit(path$$1) {
            var expr = path$$1.node;
            var name = expr.name.name;

            var validFilters = Object.keys(this.filterMap).sort().map(function (filter) {
                return '- ' + filter;
            }).join('\n    ');

            this.error('Unknown filter "' + name + '"', expr.name.loc.start, 'You\'ve tried to invoke an unknown filter called "' + name + '".\nSome of the known filters include:\n\n    ' + validFilters + '\n\nPlease report this as a bug if the filter you\'ve tried to use is listed here:\nhttp://twig.sensiolabs.org/doc/filters/index.html', name.length);
        }
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// workaround for https://github.com/rollup/rollup/issues/430
function compile(fileName, source) {
    for (var _len = arguments.length, extensions = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extensions[_key - 2] = arguments[_key];
    }

    var root = parseString.apply(undefined, [fileName, source].concat(extensions));
    var template$$1 = new Template(root.expressions),
        file$$1 = new File(fileName, template$$1),
        state = new State(file$$1, source);
    var analyseVisitor = analyse,
        convertVisitor = convert;
    for (var _iterator = extensions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
        }

        var ext = _ref;

        if (ext.visitors) {
            if (Array.isArray(ext.visitors)) {
                for (var _iterator2 = ext.visitors, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done) break;
                        _ref2 = _i2.value;
                    }

                    var visitor$$1 = _ref2;

                    if (visitor$$1.analyse) {
                        analyseVisitor = melodyTraverse.merge(analyseVisitor, visitor$$1.analyse);
                    }
                    if (visitor$$1.convert) {
                        convertVisitor = melodyTraverse.merge(convertVisitor, visitor$$1.convert);
                    }
                }
            } else {
                if (ext.visitors.analyse) {
                    analyseVisitor = melodyTraverse.merge(analyseVisitor, ext.visitors.analyse);
                }
                if (ext.visitors.convert) {
                    convertVisitor = melodyTraverse.merge(convertVisitor, ext.visitors.convert);
                }
            }
        }
        if (ext.filterMap) {
            Object.assign(state.filterMap, ext.filterMap);
        }
        if (ext.functionMap) {
            Object.assign(state.functionMap, ext.functionMap);
        }
        if (ext.options) {
            Object.assign(state.options, ext.options);
        }
    }
    convertVisitor = melodyTraverse.merge(convertVisitor, validate);
    var scope = melodyTraverse.Scope.get(melodyTraverse.Path.get({
        container: file$$1,
        key: 'template'
    }));
    melodyTraverse.traverse(file$$1, analyseVisitor, scope, state);
    melodyTraverse.traverse(file$$1, convertVisitor, scope, state);
    return t.file(file$$1.template);
}

function parseString(fileName, source) {
    var lexer = new melodyParser.Lexer(new melodyParser.CharStream(source));

    for (var _len2 = arguments.length, extensions = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        extensions[_key2 - 2] = arguments[_key2];
    }

    for (var _iterator3 = extensions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
        } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
        }

        var ext = _ref3;

        if (ext.unaryOperators) {
            lexer.addOperators.apply(lexer, ext.unaryOperators.map(function (op) {
                return op.text;
            }));
        }
        if (ext.binaryOperators) {
            lexer.addOperators.apply(lexer, ext.binaryOperators.map(function (op) {
                return op.text;
            }));
        }
    }
    var parser = new melodyParser.Parser(new melodyParser.TokenStream(lexer));
    for (var _iterator4 = extensions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
            if (_i4 >= _iterator4.length) break;
            _ref4 = _iterator4[_i4++];
        } else {
            _i4 = _iterator4.next();
            if (_i4.done) break;
            _ref4 = _i4.value;
        }

        var extension = _ref4;

        if (extension.tags) {
            for (var _iterator5 = extension.tags, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done) break;
                    _ref5 = _i5.value;
                }

                var tag = _ref5;

                parser.addTag(tag);
            }
        }
        if (extension.unaryOperators) {
            for (var _iterator6 = extension.unaryOperators, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
                var _ref6;

                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done) break;
                    _ref6 = _i6.value;
                }

                var op = _ref6;

                parser.addUnaryOperator(op);
            }
        }
        if (extension.binaryOperators) {
            for (var _iterator7 = extension.binaryOperators, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
                var _ref7;

                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done) break;
                    _ref7 = _i7.value;
                }

                var _op = _ref7;

                parser.addBinaryOperator(_op);
            }
        }
        if (extension.tests) {
            for (var _iterator8 = extension.tests, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
                var _ref8;

                if (_isArray8) {
                    if (_i8 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    _i8 = _iterator8.next();
                    if (_i8.done) break;
                    _ref8 = _i8.value;
                }

                var test = _ref8;

                parser.addTest(test);
            }
        }
    }

    return parser.parse();
}

function toString(jsAst, code) {
    return generate(jsAst, null, code);
}

exports.Template = Template;
exports.File = File;
exports.TokenTypes = melodyParser.TokenTypes;
exports.compile = compile;
exports.toString = toString;
