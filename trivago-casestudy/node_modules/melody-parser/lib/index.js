'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var n = require('melody-types');
var he = require('he');
var trimEnd = _interopDefault(require('lodash/trimEnd'));
var trimStart = _interopDefault(require('lodash/trimStart'));
var codeFrame = _interopDefault(require('melody-code-frame'));

var _ERROR_TABLE;

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EXPRESSION_START = 'expressionStart';
var EXPRESSION_END = 'expressionEnd';
var TAG_START = 'tagStart';
var TAG_END = 'tagEnd';
var INTERPOLATION_START = 'interpolationStart';
var INTERPOLATION_END = 'interpolationEnd';
var STRING_START = 'stringStart';
var STRING_END = 'stringEnd';
var COMMENT = 'comment';
var WHITESPACE = 'whitespace';
var HTML_COMMENT = 'htmlComment';
var TEXT = 'text';
var ENTITY = 'entity';
var SYMBOL = 'symbol';
var STRING = 'string';
var OPERATOR = 'operator';
var TRUE = 'true';
var FALSE = 'false';
var NULL = 'null';
var LBRACE = '[';
var RBRACE = ']';
var LPAREN = '(';
var RPAREN = ')';
var LBRACKET = '{';
var RBRACKET = '}';
var COLON = ':';
var COMMA = ',';
var DOT = '.';
var PIPE = '|';
var QUESTION_MARK = '?';
var ASSIGNMENT = '=';
var ELEMENT_START = '<';
var SLASH = '/';
var ELEMENT_END = '>';
var NUMBER = 'number';
var EOF = 'EOF';
var ERROR = 'ERROR';
var EOF_TOKEN = {
    type: EOF,
    pos: {
        index: -1,
        line: -1,
        pos: -1
    },
    end: -1,
    length: 0,
    source: null,
    text: ''
};

var ERROR_TABLE = (_ERROR_TABLE = {}, _ERROR_TABLE[EXPRESSION_END] = 'expression end "}}"', _ERROR_TABLE[EXPRESSION_START] = 'expression start "{{"', _ERROR_TABLE[TAG_START] = 'tag start "{%"', _ERROR_TABLE[TAG_END] = 'tag end "%}"', _ERROR_TABLE[INTERPOLATION_START] = 'interpolation start "#{"', _ERROR_TABLE[INTERPOLATION_END] = 'interpolation end "}"', _ERROR_TABLE);

var TokenTypes = Object.freeze({
	EXPRESSION_START: EXPRESSION_START,
	EXPRESSION_END: EXPRESSION_END,
	TAG_START: TAG_START,
	TAG_END: TAG_END,
	INTERPOLATION_START: INTERPOLATION_START,
	INTERPOLATION_END: INTERPOLATION_END,
	STRING_START: STRING_START,
	STRING_END: STRING_END,
	COMMENT: COMMENT,
	WHITESPACE: WHITESPACE,
	HTML_COMMENT: HTML_COMMENT,
	TEXT: TEXT,
	ENTITY: ENTITY,
	SYMBOL: SYMBOL,
	STRING: STRING,
	OPERATOR: OPERATOR,
	TRUE: TRUE,
	FALSE: FALSE,
	NULL: NULL,
	LBRACE: LBRACE,
	RBRACE: RBRACE,
	LPAREN: LPAREN,
	RPAREN: RPAREN,
	LBRACKET: LBRACKET,
	RBRACKET: RBRACKET,
	COLON: COLON,
	COMMA: COMMA,
	DOT: DOT,
	PIPE: PIPE,
	QUESTION_MARK: QUESTION_MARK,
	ASSIGNMENT: ASSIGNMENT,
	ELEMENT_START: ELEMENT_START,
	SLASH: SLASH,
	ELEMENT_END: ELEMENT_END,
	NUMBER: NUMBER,
	EOF: EOF,
	ERROR: ERROR,
	EOF_TOKEN: EOF_TOKEN,
	ERROR_TABLE: ERROR_TABLE
});

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LEFT = Symbol();
var RIGHT = Symbol();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setStartFromToken(node, _ref) {
    var _ref$pos = _ref.pos,
        index = _ref$pos.index,
        line = _ref$pos.line,
        column = _ref$pos.column;

    node.loc.start = { line: line, column: column, index: index };
    return node;
}

function setEndFromToken(node, _ref2) {
    var _ref2$pos = _ref2.pos,
        line = _ref2$pos.line,
        column = _ref2$pos.column,
        end = _ref2.end;

    node.loc.end = { line: line, column: column, index: end };
    return node;
}

function copyStart(node, _ref3) {
    var _ref3$loc$start = _ref3.loc.start,
        line = _ref3$loc$start.line,
        column = _ref3$loc$start.column,
        index = _ref3$loc$start.index;

    node.loc.start.line = line;
    node.loc.start.column = column;
    node.loc.start.index = index;
    return node;
}

function copyEnd(node, end) {
    node.loc.end.line = end.loc.end.line;
    node.loc.end.column = end.loc.end.column;
    node.loc.end.index = end.loc.end.index;
    return node;
}

function copyLoc(node, _ref4) {
    var _ref4$loc = _ref4.loc,
        start = _ref4$loc.start,
        end = _ref4$loc.end;

    node.loc.start.line = start.line;
    node.loc.start.column = start.column;
    node.loc.start.index = start.index;
    node.loc.end.line = end.line;
    node.loc.end.column = end.column;
    node.loc.end.index = end.index;
    return node;
}

function createNode(Type, token) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    return setEndFromToken(setStartFromToken(new (Function.prototype.bind.apply(Type, [null].concat(args)))(), token), token);
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://www.w3.org/TR/html5/syntax.html#void-elements
var voidElements = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
};

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var UNARY = Symbol();
var BINARY = Symbol();
var TAG = Symbol();
var TEST = Symbol();

var Parser = function () {
    function Parser(tokenStream) {
        _classCallCheck(this, Parser);

        this.tokens = tokenStream;
        this[UNARY] = {};
        this[BINARY] = {};
        this[TAG] = {};
        this[TEST] = {};
    }

    Parser.prototype.addUnaryOperator = function addUnaryOperator(op) {
        this[UNARY][op.text] = op;
        return this;
    };

    Parser.prototype.addBinaryOperator = function addBinaryOperator(op) {
        this[BINARY][op.text] = op;
        return this;
    };

    Parser.prototype.addTag = function addTag(tag) {
        this[TAG][tag.name] = tag;
        return this;
    };

    Parser.prototype.addTest = function addTest(test) {
        this[TEST][test.text] = test;
    };

    Parser.prototype.hasTest = function hasTest(test) {
        return !!this[TEST][test];
    };

    Parser.prototype.getTest = function getTest(test) {
        return this[TEST][test];
    };

    Parser.prototype.isUnary = function isUnary(token) {
        return token.type === OPERATOR && !!this[UNARY][token.text];
    };

    Parser.prototype.getBinaryOperator = function getBinaryOperator(token) {
        return token.type === OPERATOR && this[BINARY][token.text];
    };

    Parser.prototype.parse = function parse() {
        var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var tokens = this.tokens,
            p = setStartFromToken(new n.SequenceExpression(), tokens.la(0));
        while (!tokens.test(EOF)) {
            var token = tokens.next();
            if (!p) {
                p = setStartFromToken(new n.SequenceExpression(), token);
            }
            if (test && test(tokens.la(0).text, token, tokens)) {
                setEndFromToken(p, token);
                return p;
            }
            switch (token.type) {
                case EXPRESSION_START:
                    {
                        var expression = this.matchExpression();
                        p.add(copyLoc(new n.PrintExpressionStatement(expression), expression));
                        setEndFromToken(p, tokens.expect(EXPRESSION_END));
                        break;
                    }
                case TAG_START:
                    p.add(this.matchTag());
                    break;
                case TEXT:
                    p.add(createNode(n.PrintTextStatement, token, createNode(n.StringLiteral, token, token.text)));
                    break;
                case ENTITY:
                    p.add(createNode(n.PrintTextStatement, token, createNode(n.StringLiteral, token, he.decode(token.text))));
                    break;
                case ELEMENT_START:
                    p.add(this.matchElement());
                    break;
            }
        }
        return p;
    };

    /**
     * matchElement = '<' SYMBOL attributes* '/'? '>' (children)* '<' '/' SYMBOL '>'
     * attributes = SYMBOL '=' (matchExpression | matchString)
     *              | matchExpression
     */


    Parser.prototype.matchElement = function matchElement() {
        var tokens = this.tokens,
            elementStartToken = tokens.la(0),
            elementName = void 0,
            element = void 0;
        if (!(elementName = tokens.nextIf(SYMBOL))) {
            this.error({
                title: 'Expected element start',
                pos: elementStartToken.pos,
                advice: tokens.lat(0) === SLASH ? 'Unexpected closing "' + tokens.la(1).text + '" tag. Seems like your DOM is out of control.' : 'Expected an element to start'
            });
        }

        element = new n.Element(elementName.text);
        setStartFromToken(element, elementStartToken);

        this.matchAttributes(element, tokens);

        if (tokens.nextIf(SLASH)) {
            tokens.expect(ELEMENT_END);
            element.selfClosing = true;
        } else {
            tokens.expect(ELEMENT_END);
            if (voidElements[elementName.text]) {
                element.selfClosing = true;
            } else {
                element.children = this.parse(function (_, token, tokens) {
                    if (token.type === ELEMENT_START && tokens.lat(0) === SLASH) {
                        var name = tokens.la(1);
                        if (name.type === SYMBOL && name.text === elementName.text) {
                            tokens.next(); // SLASH
                            tokens.next(); // elementName
                            tokens.expect(ELEMENT_END);
                            return true;
                        }
                    }
                    return false;
                }).expressions;
            }
        }
        setEndFromToken(element, tokens.la(-1));
        return element;
    };

    Parser.prototype.matchAttributes = function matchAttributes(element, tokens) {
        while (tokens.lat(0) !== SLASH && tokens.lat(0) !== ELEMENT_END) {
            var key = tokens.nextIf(SYMBOL);
            if (key) {
                var keyNode = new n.Identifier(key.text);
                setStartFromToken(keyNode, key);
                setEndFromToken(keyNode, key);

                // match an attribute
                if (tokens.nextIf(ASSIGNMENT)) {
                    var start = tokens.expect(STRING_START);
                    var canBeString = true,
                        nodes = [],
                        token = void 0;
                    while (!tokens.test(STRING_END)) {
                        if (canBeString && (token = tokens.nextIf(STRING))) {
                            nodes[nodes.length] = createNode(n.StringLiteral, token, token.text);
                            canBeString = false;
                        } else if (token = tokens.nextIf(EXPRESSION_START)) {
                            nodes[nodes.length] = this.matchExpression();
                            tokens.expect(EXPRESSION_END);
                            canBeString = true;
                        } else {
                            break;
                        }
                    }
                    tokens.expect(STRING_END);
                    if (!nodes.length) {
                        nodes.push(createNode(n.StringLiteral, start, ''));
                    }

                    var expr = nodes[0];
                    for (var i = 1, len = nodes.length; i < len; i++) {
                        var _expr$loc$start = expr.loc.start,
                            line = _expr$loc$start.line,
                            column = _expr$loc$start.column;

                        expr = new n.BinaryConcatExpression(expr, nodes[i]);
                        expr.loc.start.line = line;
                        expr.loc.start.column = column;
                        copyEnd(expr, expr.right);
                    }
                    var attr = new n.Attribute(keyNode, expr);
                    copyStart(attr, keyNode);
                    copyEnd(attr, expr);
                    element.attributes.push(attr);
                } else {
                    element.attributes.push(copyLoc(new n.Attribute(keyNode), keyNode));
                }
            } else if (tokens.nextIf(EXPRESSION_START)) {
                element.attributes.push(this.matchExpression());
                tokens.expect(EXPRESSION_END);
            } else {
                this.error({
                    title: 'Invalid token',
                    pos: tokens.la(0).pos,
                    advice: 'A tag must consist of attributes or expressions. Twig Tags are not allowed.'
                });
            }
        }
    };

    Parser.prototype.error = function error(options) {
        this.tokens.error(options.title, options.pos, options.advice);
    };

    Parser.prototype.matchTag = function matchTag() {
        var tokens = this.tokens,
            tag = tokens.expect(SYMBOL),
            parser = this[TAG][tag.text];
        if (!parser) {
            tokens.error('Unknown tag "' + tag.text + '"', tag.pos, 'Expected a known tag such as\n- ' + Object.getOwnPropertyNames(this[TAG]).join('\n- '), tag.length);
        }
        return parser.parse(this, tag);
    };

    Parser.prototype.matchExpression = function matchExpression() {
        var precedence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var expr = this.getPrimary(),
            tokens = this.tokens,
            token = void 0,
            op = void 0;
        while ((token = tokens.la(0)) && token.type !== EOF && (op = this.getBinaryOperator(token)) && op.precedence >= precedence) {
            var opToken = tokens.next(); // consume the operator
            if (op.parse) {
                expr = op.parse(this, opToken, expr);
            } else {
                var expr1 = this.matchExpression(op.associativity === LEFT ? op.precedence + 1 : op.precedence);
                expr = op.createNode(token, expr, expr1);
            }
            token = tokens.la(0);
        }

        return precedence === 0 ? this.matchConditionalExpression(expr) : expr;
    };

    Parser.prototype.getPrimary = function getPrimary() {
        var tokens = this.tokens,
            token = tokens.la(0);
        if (this.isUnary(token)) {
            var op = this[UNARY][token.text];
            tokens.next(); // consume operator
            var expr = this.matchExpression(op.precedence);
            return this.matchPostfixExpression(op.createNode(token, expr));
        } else if (tokens.test(LPAREN)) {
            tokens.next(); // consume '('
            var _expr = this.matchExpression();
            tokens.expect(RPAREN);
            return this.matchPostfixExpression(_expr);
        }

        return this.matchPrimaryExpression();
    };

    Parser.prototype.matchPrimaryExpression = function matchPrimaryExpression() {
        var tokens = this.tokens,
            token = tokens.la(0),
            node = void 0;
        switch (token.type) {
            case NULL:
                node = createNode(n.NullLiteral, tokens.next());
                break;
            case FALSE:
                node = createNode(n.BooleanLiteral, tokens.next(), false);
                break;
            case TRUE:
                node = createNode(n.BooleanLiteral, tokens.next(), true);
                break;
            case SYMBOL:
                tokens.next();
                if (tokens.test(LPAREN)) {
                    // SYMBOL '(' arguments* ')'
                    node = new n.CallExpression(createNode(n.Identifier, token, token.text), this.matchArguments());
                    copyStart(node, node.callee);
                    setEndFromToken(node, tokens.la(-1)); // ')'
                } else {
                    node = createNode(n.Identifier, token, token.text);
                }
                break;
            case NUMBER:
                node = createNode(n.NumericLiteral, token, Number(tokens.next()));
                break;
            case STRING_START:
                node = this.matchStringExpression();
                break;
            // potentially missing: OPERATOR type
            default:
                if (token.type === LBRACE) {
                    node = this.matchArray();
                } else if (token.type === LBRACKET) {
                    node = this.matchMap();
                } else {
                    this.error({
                        title: 'Unexpected token "' + token.type + '" of value "' + token.text + '"',
                        pos: token.pos
                    });
                }
                break;
        }

        return this.matchPostfixExpression(node);
    };

    Parser.prototype.matchStringExpression = function matchStringExpression() {
        var tokens = this.tokens,
            nodes = [],
            canBeString = true,
            token = void 0,
            stringStart = void 0,
            stringEnd = void 0;
        stringStart = tokens.expect(STRING_START);
        while (!tokens.test(STRING_END)) {
            if (canBeString && (token = tokens.nextIf(STRING))) {
                nodes[nodes.length] = createNode(n.StringLiteral, token, token.text);
                canBeString = false;
            } else if (token = tokens.nextIf(INTERPOLATION_START)) {
                nodes[nodes.length] = this.matchExpression();
                tokens.expect(INTERPOLATION_END);
                canBeString = true;
            } else {
                break;
            }
        }
        stringEnd = tokens.expect(STRING_END);

        if (!nodes.length) {
            return setEndFromToken(createNode(n.StringLiteral, stringStart, ''), stringEnd);
        }

        var expr = nodes[0];
        for (var i = 1, len = nodes.length; i < len; i++) {
            var _expr$loc$start2 = expr.loc.start,
                line = _expr$loc$start2.line,
                column = _expr$loc$start2.column;

            expr = new n.BinaryConcatExpression(expr, nodes[i]);
            expr.loc.start.line = line;
            expr.loc.start.column = column;
            copyEnd(expr, expr.right);
        }

        return expr;
    };

    Parser.prototype.matchConditionalExpression = function matchConditionalExpression(test) {
        var tokens = this.tokens,
            condition = test,
            consequent = void 0,
            alternate = void 0;
        while (tokens.nextIf(QUESTION_MARK)) {
            if (!tokens.nextIf(COLON)) {
                consequent = this.matchExpression();
                if (tokens.nextIf(COLON)) {
                    alternate = this.matchExpression();
                } else {
                    alternate = null;
                }
            } else {
                consequent = null;
                alternate = this.matchExpression();
            }
            var _condition$loc$start = condition.loc.start,
                line = _condition$loc$start.line,
                column = _condition$loc$start.column;

            condition = new n.ConditionalExpression(condition, consequent, alternate);
            condition.loc.start = { line: line, column: column };
            copyEnd(condition, alternate || consequent);
        }
        return condition;
    };

    Parser.prototype.matchArray = function matchArray() {
        var tokens = this.tokens,
            array = new n.ArrayExpression(),
            start = tokens.expect(LBRACE);
        setStartFromToken(array, start);
        while (!tokens.test(RBRACE) && !tokens.test(EOF)) {
            array.elements.push(this.matchExpression());
            if (!tokens.test(RBRACE)) {
                tokens.expect(COMMA);
                // support trailing commas
                if (tokens.test(RBRACE)) {
                    break;
                }
            }
        }
        setEndFromToken(array, tokens.expect(RBRACE));
        return array;
    };

    Parser.prototype.matchMap = function matchMap() {
        var tokens = this.tokens,
            token = void 0,
            obj = new n.ObjectExpression(),
            startToken = tokens.expect(LBRACKET);
        setStartFromToken(obj, startToken);
        while (!tokens.test(RBRACKET) && !tokens.test(EOF)) {
            var computed = false,
                key = void 0,
                value = void 0;
            if (tokens.test(STRING_START)) {
                key = this.matchStringExpression();
                if (!n.is('StringLiteral', key)) {
                    computed = true;
                }
            } else if (token = tokens.nextIf(SYMBOL)) {
                key = createNode(n.Identifier, token, token.text);
            } else if (token = tokens.nextIf(NUMBER)) {
                key = createNode(n.NumericLiteral, token, Number(token.text));
            } else if (tokens.test(LPAREN)) {
                key = this.matchExpression();
                computed = true;
            } else {
                this.error({
                    title: 'Invalid map key',
                    pos: tokens.la(0).pos,
                    advice: 'Key must be a string, symbol or a number but was ' + tokens.next()
                });
            }
            tokens.expect(COLON);
            value = this.matchExpression();
            var prop = new n.ObjectProperty(key, value, computed);
            copyStart(prop, key);
            copyEnd(prop, value);
            obj.properties.push(prop);
            if (!tokens.test(RBRACKET)) {
                tokens.expect(COMMA);
                // support trailing comma
                if (tokens.test(RBRACKET)) {
                    break;
                }
            }
        }
        setEndFromToken(obj, tokens.expect(RBRACKET));
        return obj;
    };

    Parser.prototype.matchPostfixExpression = function matchPostfixExpression(expr) {
        var tokens = this.tokens;
        var node = expr;
        while (!tokens.test(EOF)) {
            if (tokens.test(DOT) || tokens.test(LBRACE)) {
                node = this.matchSubscriptExpression(node);
            } else if (tokens.test(PIPE)) {
                tokens.next();
                node = this.matchFilterExpression(node);
            } else {
                break;
            }
        }

        return node;
    };

    Parser.prototype.matchSubscriptExpression = function matchSubscriptExpression(node) {
        var tokens = this.tokens,
            op = tokens.next();
        if (op.type === DOT) {
            var token = tokens.next(),
                computed = false,
                property = void 0;
            if (token.type === SYMBOL) {
                property = createNode(n.Identifier, token, token.text);
            } else if (token.type === NUMBER) {
                property = createNode(n.NumericLiteral, token, Number(token.text));
                computed = true;
            } else {
                this.error({
                    title: 'Invalid token',
                    pos: token.pos,
                    advice: 'Expected number or symbol, found ' + token + ' instead'
                });
            }

            var memberExpr = new n.MemberExpression(node, property, computed);
            copyStart(memberExpr, node);
            copyEnd(memberExpr, property);
            if (tokens.test(LPAREN)) {
                var callExpr = new n.CallExpression(memberExpr, this.matchArguments());
                copyStart(callExpr, memberExpr);
                setEndFromToken(callExpr, tokens.la(-1));
                return callExpr;
            }
            return memberExpr;
        } else {
            var arg = void 0,
                start = void 0;
            if (tokens.test(COLON)) {
                // slice
                tokens.next();
                start = null;
            } else {
                arg = this.matchExpression();
                if (tokens.test(COLON)) {
                    start = arg;
                    arg = null;
                    tokens.next();
                }
            }

            if (arg) {
                return setEndFromToken(copyStart(new n.MemberExpression(node, arg, true), node), tokens.expect(RBRACE));
            } else {
                // slice
                var result = new n.SliceExpression(node, start, tokens.test(RBRACE) ? null : this.matchExpression());
                copyStart(result, node);
                setEndFromToken(result, tokens.expect(RBRACE));
                return result;
            }
        }
    };

    Parser.prototype.matchFilterExpression = function matchFilterExpression(node) {
        var tokens = this.tokens,
            target = node;
        while (!tokens.test(EOF)) {
            var token = tokens.expect(SYMBOL),
                name = createNode(n.Identifier, token, token.text),
                args = void 0;
            if (tokens.test(LPAREN)) {
                args = this.matchArguments();
            } else {
                args = [];
            }
            var newTarget = new n.FilterExpression(target, name, args);
            copyStart(newTarget, target);
            if (newTarget.arguments.length) {
                copyEnd(newTarget, newTarget.arguments[newTarget.arguments.length - 1]);
            } else {
                copyEnd(newTarget, target);
            }
            target = newTarget;

            if (!tokens.test(PIPE) || tokens.test(EOF)) {
                break;
            }

            tokens.next(); // consume '|'
        }
        return target;
    };

    Parser.prototype.matchArguments = function matchArguments() {
        var tokens = this.tokens,
            args = [];
        tokens.expect(LPAREN);
        while (!tokens.test(RPAREN) && !tokens.test(EOF)) {
            if (tokens.test(SYMBOL) && tokens.lat(1) === ASSIGNMENT) {
                var name = tokens.next();
                tokens.next();
                var value = this.matchExpression();
                var arg = new n.NamedArgumentExpression(createNode(n.Identifier, name, name.text), value);
                copyEnd(arg, value);
                args.push(arg);
            } else {
                args.push(this.matchExpression());
            }

            if (!tokens.test(COMMA)) {
                tokens.expect(RPAREN);
                return args;
            }
            tokens.expect(COMMA);
        }
        tokens.expect(RPAREN);
        return args;
    };

    return Parser;
}();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TOKENS = Symbol();
var LENGTH = Symbol();

var TokenStream = function () {
    function TokenStream(lexer) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { ignoreComments: true, ignoreWhitespace: true };

        _classCallCheck$1(this, TokenStream);

        this.input = lexer;
        this.index = 0;
        this.options = options;
        this[TOKENS] = getAllTokens(lexer, options);
        this[LENGTH] = this[TOKENS].length;

        if (this[TOKENS].length && this[TOKENS][this[TOKENS].length - 1].type === ERROR) {
            var errorToken = this[TOKENS][this[TOKENS].length - 1];
            this.error(errorToken.message, errorToken.pos, errorToken.advice, errorToken.endPos.index - errorToken.pos.index || 1);
        }
    }

    TokenStream.prototype.la = function la(offset) {
        var index = this.index + offset;
        return index < this[LENGTH] ? this[TOKENS][index] : EOF_TOKEN;
    };

    TokenStream.prototype.lat = function lat(offset) {
        return this.la(offset).type;
    };

    TokenStream.prototype.test = function test(type, text) {
        var token = this.la(0);
        return token.type === type && (!text || token.text === text);
    };

    TokenStream.prototype.next = function next() {
        if (this.index === this[LENGTH]) {
            return EOF_TOKEN;
        }
        var token = this[TOKENS][this.index];
        this.index++;
        return token;
    };

    TokenStream.prototype.nextIf = function nextIf(type, text) {
        if (this.test(type, text)) {
            return this.next();
        }
        return false;
    };

    TokenStream.prototype.expect = function expect(type, text) {
        var token = this.la(0);
        if (token.type === type && (!text || token.text === text)) {
            return this.next();
        }
        this.error('Invalid Token', token.pos, 'Expected ' + (ERROR_TABLE[type] || type || text) + ' but found ' + (ERROR_TABLE[token.type] || token.type || token.text) + ' instead.', token.length);
    };

    TokenStream.prototype.error = function error(message, pos, advice) {
        var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        var errorMessage = 'ERROR: ' + message + '\n';
        errorMessage += codeFrame({
            rawLines: this.input.source,
            lineNumber: pos.line,
            colNumber: pos.column,
            length: length,
            tokens: getAllTokens(this.input, {
                ignoreWhitespace: false,
                ignoreComments: false,
                ignoreHtmlComments: false
            })
        });
        if (advice) {
            errorMessage += '\n\n' + advice;
        }
        throw new Error(errorMessage);
    };

    return TokenStream;
}();

function getAllTokens(lexer, options) {
    var token = void 0,
        tokens = [],
        acceptWhitespaceControl = false,
        trimNext = false;
    while ((token = lexer.next()) !== EOF_TOKEN) {
        var shouldTrimNext = trimNext;
        trimNext = false;
        if (acceptWhitespaceControl) {
            switch (token.type) {
                case EXPRESSION_START:
                case TAG_START:
                    if (token.text[token.text.length - 1] === '-') {
                        tokens[tokens.length - 1].text = trimEnd(tokens[tokens.length - 1].text);
                    }
                    break;
                case EXPRESSION_END:
                case TAG_END:
                    if (token.text[0] === '-') {
                        trimNext = true;
                    }
                    break;
                case COMMENT:
                    if (tokens[tokens.length - 1].type === TEXT) {
                        tokens[tokens.length - 1].text = trimEnd(tokens.text);
                    }
                    trimNext = true;
                    break;
            }
        }
        if (shouldTrimNext && (token.type === TEXT || token.type === STRING)) {
            token.text = trimStart(token.text);
        }
        if ((token.type !== COMMENT || !options.ignoreComments) && (token.type !== WHITESPACE || !options.ignoreWhitespace) && (token.type !== HTML_COMMENT || !options.ignoreHtmlComments)) {
            tokens[tokens.length] = token;
        }
        acceptWhitespaceControl = true;
        if (token.type === ERROR) {
            return tokens;
        }
    }
    return tokens;
}

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var EOF$1 = Symbol();

var CharStream = function () {
    function CharStream(input) {
        _classCallCheck$3(this, CharStream);

        this.input = String(input);
        this.length = this.input.length;
        this.index = 0;
        this.position = { line: 1, column: 0 };
    }

    CharStream.prototype.reset = function reset() {
        this.rewind({ line: 1, column: 0, index: 0 });
    };

    CharStream.prototype.mark = function mark() {
        var _position = this.position,
            line = _position.line,
            column = _position.column,
            index = this.index;

        return { line: line, column: column, index: index };
    };

    CharStream.prototype.rewind = function rewind(marker) {
        this.position.line = marker.line;
        this.position.column = marker.column;
        this.index = marker.index;
    };

    CharStream.prototype.la = function la(offset) {
        var index = this.index + offset;
        return index < this.length ? this.input.charAt(index) : EOF$1;
    };

    CharStream.prototype.lac = function lac(offset) {
        var index = this.index + offset;
        return index < this.length ? this.input.charCodeAt(index) : EOF$1;
    };

    CharStream.prototype.next = function next() {
        if (this.index === this.length) {
            return EOF$1;
        }
        var ch = this.input.charAt(this.index);
        this.index++;
        this.position.column++;
        if (ch === '\n') {
            this.position.line += 1;
            this.position.column = 0;
        }
        return ch;
    };

    CharStream.prototype.match = function match(str) {
        var start = this.mark();
        for (var i = 0, len = str.length; i < len; i++) {
            var ch = this.next();
            if (ch !== str.charAt(i) || ch === EOF$1) {
                this.rewind(start);
                return false;
            }
        }
        return true;
    };

    _createClass$1(CharStream, [{
        key: 'source',
        get: function get() {
            return this.input;
        }
    }]);

    return CharStream;
}();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var State = {
    TEXT: 'TEXT',
    EXPRESSION: 'EXPRESSION',
    TAG: 'TAG',
    INTERPOLATION: 'INTERPOLATION',
    STRING_SINGLE: 'STRING_SINGLE',
    STRING_DOUBLE: 'STRING_DOUBLE',
    ELEMENT: 'ELEMENT',
    ATTRIBUTE_VALUE: 'ATTRIBUTE_VALUE'
};

var STATE = Symbol();
var OPERATORS = Symbol();
var STRING_START$1 = Symbol();

var CHAR_TO_TOKEN = {
    '[': LBRACE,
    ']': RBRACE,
    '(': LPAREN,
    ')': RPAREN,
    '{': LBRACKET,
    '}': RBRACKET,
    ':': COLON,
    '.': DOT,
    '|': PIPE,
    ',': COMMA,
    '?': QUESTION_MARK,
    '=': ASSIGNMENT,
    //'<': TokenTypes.ELEMENT_START,
    //'>': TokenTypes.ELEMENT_END,
    '/': SLASH
};

var Lexer = function () {
    function Lexer(input) {
        _classCallCheck$2(this, Lexer);

        this.input = input;
        this[STATE] = [State.TEXT];
        this[OPERATORS] = [];
        this[STRING_START$1] = null;
    }

    Lexer.prototype.reset = function reset() {
        this.input.reset();
        this[STATE] = [State.TEXT];
    };

    Lexer.prototype.addOperators = function addOperators() {
        var _OPERATORS;

        (_OPERATORS = this[OPERATORS]).push.apply(_OPERATORS, arguments);
        this[OPERATORS].sort(function (a, b) {
            return a.length > b.length ? -1 : 1;
        });
    };

    Lexer.prototype.pushState = function pushState(state) {
        this[STATE].push(state);
    };

    Lexer.prototype.popState = function popState() {
        this[STATE].length--;
    };

    Lexer.prototype.createToken = function createToken(type, pos) {
        var input = this.input,
            endPos = input.mark(),
            end = endPos.index;
        return {
            type: type,
            pos: pos,
            endPos: endPos,
            end: end,
            length: end - pos.index,
            source: input.input,
            text: input.input.substr(pos.index, end - pos.index),
            toString: function toString() {
                return this.text;
            }
        };
    };

    Lexer.prototype.next = function next() {
        var input = this.input,
            pos = void 0,
            c = void 0;
        while ((c = input.la(0)) !== EOF$1) {
            pos = input.mark();
            if (this.state !== State.TEXT && this.state !== State.STRING_DOUBLE && this.state !== State.STRING_SINGLE && this.state !== State.ATTRIBUTE_VALUE && isWhitespace(c)) {
                input.next();
                while ((c = input.la(0)) !== EOF$1 && isWhitespace(c)) {
                    input.next();
                }
                return this.createToken(WHITESPACE, pos);
            }
            if (c === '{' && input.la(1) === '#') {
                input.next();
                input.next();
                if (input.la(0) === '-') {
                    input.next();
                }
                while ((c = input.la(0)) !== EOF$1) {
                    if (c === '#' && input.la(1) === '}' || c === '-' && input.la(1) === '#' && input.la(2) === '}') {
                        if (c === '-') {
                            input.next();
                        }
                        input.next();
                        input.next();
                        return this.createToken(COMMENT, pos);
                    }
                    input.next();
                }
            }
            if (this.state === State.TEXT) {
                var entityToken = void 0;
                if (c === '<') {
                    if (input.la(1) === '{' || isAlpha(input.lac(1)) || input.la(1) === '/') {
                        input.next();
                        this.pushState(State.ELEMENT);
                        return this.createToken(ELEMENT_START, pos);
                    } else if (input.la(1) === '!' && input.la(2) === '-' && input.la(3) === '-') {
                        // match HTML comment
                        input.next(); // <
                        input.next(); // !
                        input.next(); // -
                        input.next(); // -
                        while ((c = input.la(0)) !== EOF$1) {
                            if (c === '-' && input.la(1) === '-') {
                                input.next();
                                input.next();
                                if (!(c = input.next()) === '>') {
                                    this.error('Unexpected end for HTML comment', input.mark(), 'Expected comment to end with \'>\' but found \'' + c + '\' instead.');
                                }
                                break;
                            }
                            input.next();
                        }
                        return this.createToken(HTML_COMMENT, pos);
                    } else {
                        return this.matchText(pos);
                    }
                } else if (c === '{') {
                    return this.matchExpressionToken(pos);
                } else if (c === '&' && (entityToken = this.matchEntity(pos))) {
                    return entityToken;
                } else {
                    return this.matchText(pos);
                }
            } else if (this.state === State.EXPRESSION) {
                if (c === '}' && input.la(1) === '}' || c === '-' && input.la(1) === '}' && input.la(2) === '}') {
                    if (c === '-') {
                        input.next();
                    }
                    input.next();
                    input.next();
                    this.popState();
                    return this.createToken(EXPRESSION_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.TAG) {
                if (c === '%' && input.la(1) === '}' || c === '-' && input.la(1) === '%' && input.la(2) === '}') {
                    if (c === '-') {
                        input.next();
                    }
                    input.next();
                    input.next();
                    this.popState();
                    return this.createToken(TAG_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.STRING_SINGLE || this.state === State.STRING_DOUBLE) {
                return this.matchString(pos, true);
            } else if (this.state === State.INTERPOLATION) {
                if (c === '}') {
                    input.next();
                    this.popState(); // pop interpolation
                    return this.createToken(INTERPOLATION_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.ELEMENT) {
                switch (c) {
                    case '/':
                        input.next();
                        return this.createToken(SLASH, pos);
                    case '{':
                        return this.matchExpressionToken(pos);
                    case '>':
                        input.next();
                        this.popState();
                        return this.createToken(ELEMENT_END, pos);
                    case '"':
                        input.next();
                        this.pushState(State.ATTRIBUTE_VALUE);
                        return this.createToken(STRING_START, pos);
                    case '=':
                        input.next();
                        return this.createToken(ASSIGNMENT, pos);
                    default:
                        return this.matchSymbol(pos);
                }
            } else if (this.state === State.ATTRIBUTE_VALUE) {
                if (c === '"') {
                    input.next();
                    this.popState();
                    return this.createToken(STRING_END, pos);
                } else {
                    return this.matchAttributeValue(pos);
                }
            } else {
                return this.error('Invalid state ' + this.state, pos);
            }
        }
        return EOF_TOKEN;
    };

    Lexer.prototype.matchExpressionToken = function matchExpressionToken(pos) {
        var input = this.input;
        switch (input.la(1)) {
            case '{':
                input.next();
                input.next();
                this.pushState(State.EXPRESSION);
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.createToken(EXPRESSION_START, pos);
            case '%':
                input.next();
                input.next();
                this.pushState(State.TAG);
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.createToken(TAG_START, pos);
            case '#':
                input.next();
                input.next();
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.matchComment(pos);
            default:
                return this.matchText(pos);
        }
    };

    Lexer.prototype.matchExpression = function matchExpression(pos) {
        var input = this.input,
            c = input.la(0);
        switch (c) {
            case "'":
                this.pushState(State.STRING_SINGLE);
                input.next();
                return this.createToken(STRING_START, pos);
            case '"':
                this.pushState(State.STRING_DOUBLE);
                input.next();
                return this.createToken(STRING_START, pos);
            default:
                {
                    if (isDigit(input.lac(0))) {
                        input.next();
                        return this.matchNumber(pos);
                    }
                    if (c === 't' && input.match('true') || c === 'T' && input.match('TRUE')) {
                        return this.createToken(TRUE, pos);
                    }
                    if (c === 'f' && input.match('false') || c === 'F' && input.match('FALSE')) {
                        return this.createToken(FALSE, pos);
                    }
                    if (c === 'n' && (input.match('null') || input.match('none')) || c === 'N' && (input.match('NULL') || input.match('NONE'))) {
                        return this.createToken(NULL, pos);
                    }

                    var _findLongestMatchingO = this.findLongestMatchingOperator(),
                        longestMatchingOperator = _findLongestMatchingO.longestMatchingOperator,
                        longestMatchEndPos = _findLongestMatchingO.longestMatchEndPos;

                    var cc = input.lac(0);
                    if (cc === 95 /* _ */ || isAlpha(cc) || isDigit(cc)) {
                        // okay... this could be either a symbol or an operator
                        input.next();
                        var sym = this.matchSymbol(pos);
                        if (sym.text.length <= longestMatchingOperator.length) {
                            // the operator was longer so let's use that
                            input.rewind(longestMatchEndPos);
                            return this.createToken(OPERATOR, pos);
                        }
                        // found a symbol
                        return sym;
                    } else if (longestMatchingOperator) {
                        input.rewind(longestMatchEndPos);
                        return this.createToken(OPERATOR, pos);
                    } else if (CHAR_TO_TOKEN.hasOwnProperty(c)) {
                        input.next();
                        return this.createToken(CHAR_TO_TOKEN[c], pos);
                    } else {
                        return this.error('Unknown token ' + c, pos);
                    }
                }
        }
    };

    Lexer.prototype.findLongestMatchingOperator = function findLongestMatchingOperator() {
        var input = this.input,
            start = input.mark();
        var longestMatchingOperator = '',
            longestMatchEndPos = null;
        for (var i = 0, ops = this[OPERATORS], len = ops.length; i < len; i++) {
            var op = ops[i];
            if (op.length > longestMatchingOperator.length && input.match(op)) {
                var cc = input.lac(0);

                // prevent mixing up operators with symbols (e.g. matching
                // 'not in' in 'not invalid').
                if (op.indexOf(' ') === -1 || !(isAlpha(cc) || isDigit(cc))) {
                    longestMatchingOperator = op;
                    longestMatchEndPos = input.mark();
                }

                input.rewind(start);
            }
        }
        input.rewind(start);
        return { longestMatchingOperator: longestMatchingOperator, longestMatchEndPos: longestMatchEndPos };
    };

    Lexer.prototype.error = function error(message, pos) {
        var advice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

        var errorToken = this.createToken(ERROR, pos);
        errorToken.message = message;
        errorToken.advice = advice;
        return errorToken;
    };

    Lexer.prototype.matchEntity = function matchEntity(pos) {
        var input = this.input;
        input.next(); // &
        if (input.la(0) === '#') {
            input.next(); // #
            if (input.la(0) === 'x') {
                // hexadecimal numeric character reference
                input.next(); // x
                var c = input.la(0);
                while ('a' <= c && c <= 'f' || 'A' <= c && c <= 'F' || isDigit(input.lac(0))) {
                    input.next();
                    c = input.la(0);
                }
                if (input.la(0) === ';') {
                    input.next();
                } else {
                    input.rewind(pos);
                    return null;
                }
            } else if (isDigit(input.lac(0))) {
                // decimal numeric character reference
                // consume decimal numbers
                do {
                    input.next();
                } while (isDigit(input.lac(0)));
                // check for final ";"
                if (input.la(0) === ';') {
                    input.next();
                } else {
                    input.rewind(pos);
                    return null;
                }
            } else {
                input.rewind(pos);
                return null;
            }
        } else {
            // match named character reference
            while (isAlpha(input.lac(0))) {
                input.next();
            }
            if (input.la(0) === ';') {
                input.next();
            } else {
                input.rewind(pos);
                return null;
            }
        }
        return this.createToken(ENTITY, pos);
    };

    Lexer.prototype.matchSymbol = function matchSymbol(pos) {
        var input = this.input,
            inElement = this.state === State.ELEMENT,
            c = void 0;
        while ((c = input.lac(0)) && (c === 95 || isAlpha(c) || isDigit(c) || inElement && (c === 45 || c === 58))) {
            input.next();
        }
        var end = input.mark();
        if (pos.index === end.index) {
            return this.error('Expected an Identifier', pos, inElement ? 'Expected a valid attribute name, but instead found "' + input.la(0) + '", which is not part of a valid attribute name.' : 'Expected letter, digit or underscore but found ' + input.la(0) + ' instead.');
        }
        return this.createToken(SYMBOL, pos);
    };

    Lexer.prototype.matchString = function matchString(pos) {
        var allowInterpolation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var input = this.input,
            start = this.state === State.STRING_SINGLE ? "'" : '"';
        var c = void 0;
        // string starts with an interpolation
        if (allowInterpolation && input.la(0) === '#' && input.la(1) === '{') {
            this.pushState(State.INTERPOLATION);
            input.next();
            input.next();
            return this.createToken(INTERPOLATION_START, pos);
        }
        if (input.la(0) === start) {
            input.next();
            this.popState();
            return this.createToken(STRING_END, pos);
        }
        while ((c = input.la(0)) !== start && c !== EOF$1) {
            if (c === '\\' && input.la(1) === start) {
                // escape sequence for string start
                input.next();
                input.next();
            } else if (allowInterpolation && c === '#' && input.la(1) === '{') {
                // found interpolation start, string part matched
                // next iteration will match the interpolation
                break;
            } else {
                input.next();
            }
        }
        var result = this.createToken(STRING, pos);
        result.text = result.text.replace('\\', '');
        return result;
    };

    Lexer.prototype.matchAttributeValue = function matchAttributeValue(pos) {
        var input = this.input,
            start = this.state === State.STRING_SINGLE ? "'" : '"',
            c = void 0;
        if (input.la(0) === '{') {
            return this.matchExpressionToken(pos);
        }
        while ((c = input.la(0)) !== start && c !== EOF$1) {
            if (c === '\\' && input.la(1) === start) {
                input.next();
                input.next();
            } else if (c === '{') {
                // interpolation start
                break;
            } else if (c === start) {
                break;
            } else {
                input.next();
            }
        }
        var result = this.createToken(STRING, pos);
        result.text = result.text.replace('\\', '');
        return result;
    };

    Lexer.prototype.matchNumber = function matchNumber(pos) {
        var input = this.input,
            c = void 0;
        while ((c = input.lac(0)) !== EOF$1) {
            if (!isDigit(c)) {
                break;
            }
            input.next();
        }
        if (input.la(0) === '.') {
            input.next();
            while ((c = input.lac(0)) !== EOF$1) {
                if (!isDigit(c)) {
                    break;
                }
                input.next();
            }
        }
        return this.createToken(NUMBER, pos);
    };

    Lexer.prototype.matchText = function matchText(pos) {
        var input = this.input,
            exit = false,
            c = void 0;
        while (!exit && (c = input.la(0)) && c !== EOF$1) {
            if (c === '{') {
                var c2 = input.la(1);
                if (c2 === '{' || c2 === '#' || c2 === '%') {
                    break;
                }
            } else if (c === '<') {
                if (input.la(1) === '/' || isAlpha(input.lac(1))) {
                    break;
                } else if (input.la(1) === '{') {
                    var _c = input.la(1);
                    if (_c === '{' || _c === '#' || _c === '%') {
                        break;
                    }
                }
            }
            input.next();
        }
        return this.createToken(TEXT, pos);
    };

    Lexer.prototype.matchComment = function matchComment(pos) {
        var input = this.input,
            c = void 0;
        while ((c = input.next()) !== EOF$1) {
            if (c === '#' && input.la(0) === '}') {
                input.next(); // consume '}'
                break;
            }
        }
        return this.createToken(COMMENT, pos);
    };

    _createClass(Lexer, [{
        key: 'source',
        get: function get() {
            return this.input.source;
        }
    }, {
        key: 'state',
        get: function get() {
            return this[STATE][this[STATE].length - 1];
        }
    }]);

    return Lexer;
}();

function isWhitespace(c) {
    return c === '\n' || c === ' ' || c === '\t';
}

function isAlpha(c) {
    return 65 <= c && c <= 90 || 97 <= c && c <= 122;
}

function isDigit(c) {
    return 48 <= c && c <= 57;
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parse(code) {
    var p = new Parser(new TokenStream(new Lexer(new CharStream(code))));
    return p.parse();
}

exports.Parser = Parser;
exports.TokenStream = TokenStream;
exports.Lexer = Lexer;
exports.EOF = EOF$1;
exports.CharStream = CharStream;
exports.LEFT = LEFT;
exports.RIGHT = RIGHT;
exports.parse = parse;
exports.setStartFromToken = setStartFromToken;
exports.setEndFromToken = setEndFromToken;
exports.copyStart = copyStart;
exports.copyEnd = copyEnd;
exports.copyLoc = copyLoc;
exports.createNode = createNode;
exports.Types = TokenTypes;
